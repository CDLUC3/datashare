<!DOCTYPE html SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head><title></title></head>
  <body>
    <h1>XTF Tag Reference</h1>
    This page provides a reference for the tags, parameters, and utilities usable in XSLT stylesheets in various parts of the eXtensible Text Framework (XTF). This document assumes that you are familiar with the general organization of the XTF system as described in the XTF Programmer's Guide. Here are the available sections:
    
    <a name="top"></a>
    <ul>
      <li><a href="#textIndexer">textIndexer</a>
        <ul>
          <li><a href="#docSelector">Document Selector</a>
            <ul>
              <li><a href="#docSelector_input">Input Tags</a></li>
              <li><a href="#docSelector_output">Output Tags</a></li>
            </ul>
          </li>
          <li><a href="#preFilter">PreFilter</a>
            <ul>
              <li><a href="#preFilter_output">Output Attributes</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#crossQuery">crossQuery</a>
        <ul>
          <li><a href="#common">Common to crossQuery and dynaXML</a>
            <ul>
              <li>Stylesheet parameters</li>
              <li>Parser Input Tags</li>
              <li><a href="#ErrorGenerator">Error Generator Stylesheet</a></li>
              <li><a href="#commonUtils">Utilities</a></li>
            </ul>
          </li>
          <li>Query Router and Query Parser Tags
            <ul>
              <li><a href="#routerParserInputTagParameters">Common Input Tags and Parameters</a></li>
              <li><a href="#routerOutputTags">Query Router Output Tags</a></li>
              <li><a href="#parserOutputTags">Query Parser Output Tags</a></li>
            </ul>
          </li>
          <li>Search Result Formatter
            <ul>
              <li><a href="#searchResultInputTag">Input Tags</a></li>
            </ul>
          </li>
          <li><a href="#ErrorGenerator">Error Generator</a>
            <ul>
              <li>Input Tags</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#dynamXML">dynaXML</a>
        <ul>
          <li><a href="#common">Common to crossQuery and dynaXML</a>
            <ul>
              <li>Stylesheet parameters</li>
              <li>Parser Input Tags</li>
              <li><a href="#ErrorGenerator">Error Generator Stylesheet</a></li>
              <li><a href="#commonUtils">Utilities</a></li>
            </ul>
          </li>
          <li><a href="#DocReqParser">Document Request Parser</a>
            <ul>
              <li><a href="#tagRef_dynaXML_DocReqParser_Input">Input Tags and Parameters</a></li>
              <li><a href="#tagRef_dynaXML_DocReqParser_Output">Output Tags</a></li>
            </ul>
          </li>
          <li><a href="#DocFormatter">Document Formatter</a></li>
          <li><a href="#ErrorGenerator">Error Generator</a></li>
        </ul>
      </li>
    </ul>
    <!--Text Indexer tags-->
    <h2 style="border-bottom: medium double black;"><a name="textIndexer">textIndexer</a></h2>
    <a href="#top"><em>return to top</em></a>
    
    This section details the XTF specific tags for the textIndexer stylesheets.  There are two kinds of tags: 1) <a href="#docSelector">Document Selector tags</a> and 2) <a href="#preFilter">PreFilter tags</a>.
    <h3><a name="docSelector">1. Document Selector</a></h3>
    The following <a href="#docSelector_input">input</a> and <a href="#docSelector_output">output</a> tags make up the XML input for the <strong>Document Selector</strong> stylesheet. They constitute a simple XML representation files found in one (sub-) directory of the document library.
    <ul> 
      <li><strong>Input Tags</strong> <a name="docSelector_input"></a>
        <ul>
          <li><u>Directory Tag</u>
            This tag is the outermost tag for the XML input fragment sent to the <strong>Document Selector</strong> stylesheet for translation. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;directory dirPath="DirectoryPath"&gt;
    File
    File
    …
    File
&lt;/directory&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>dirPath="!DirectoryPath"</tt></td>
                  <td>is the absolute file path to the directory on disk.</td>
                </tr>
                <tr>
                  <td><tt>File, File...</tt></td>
                  <td>is zero or more <strong>File Tags</strong> (see below) , one for each file found in the directory.</td>
                </tr>
              </tbody>
            </table>
          </li>
          
          <li><u>File Tag</u>
            This tag is the input to the <strong>Document Selector</strong> stylesheet for each file found in the containing <tt>&lt;directory...&gt;</tt> tag. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;file fileName="FileName"/&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>fileName="!FileName"</tt></td>
                  <td>is the name of a file found in the directory identified by the containing <tt>&lt;directory...&gt;</tt> tag. Note that this file name does not contain any path information for the file, but only the file name itself.</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
      <li><strong>Output Tags</strong> <a name="docSelector_output"></a>
        <ul>
          <li><u>Index List Tag</u>
            This tag is the outermost tag for the XML output fragment issued by the <strong>Document Selector</strong> stylesheet. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;indexFiles&gt;
          
    FileToIndex
    FileToIndex
    …
    FileToIndex
    
&lt;/indexFiles&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>FileToIndex</tt>, <tt>FileToIndex</tt>...</td>
                  <td>is zero or more <strong>File To Index Tags</strong> (see below), one for each file to index in the directory.</td>
                </tr>
              </tbody>
            </table>
          </li>
          
          <li><u>File To Index Tag</u>
            
             One copy of this tag should be output by <strong>Document Selector</strong> stylesheet for each file that must be indexed. It should appear within an Index List Tag container (see above). It has the form:
             <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;file fileName      = "FileName"
      {format       = "FileFormat"}
      {preFilter    = "PreFilterPath(s)"}
      {displayStyle = "DocumentFormatterPath"}/&gt;</pre>
             where
             <table border="1">
               <tbody>
                 <tr>
                   <td><tt>fileName="</tt><em>FileName</em><tt>"</tt></td>
                   <td>is a required attribute that specifies the name of a file to be indexed. Note that this file name should not contain any path information for the file, but only the file name itself.</td>
                 </tr>
                 <tr>
                   <td><tt>format="</tt><em>FileFormat</em><tt>"</tt></td>
                   <td>is an optional attribute that specifies the format of a file to be indexed. Currently XML, PDF, HTML plain text, and most Microsoft Word files are handled by the textIndexer, and the format attribute should correspondingly be set to <tt>XML</tt>, <tt>PDF</tt>, <tt>HTML</tt>, <tt>Text</tt>, or <tt>MSWord</tt>. If this attribute is omitted, the textIndexer will try to infer the file type based on the file extension.</td>
                 </tr>
                 <tr>
                   <td><tt>preFilter="</tt><em>PreFilterPath(s)</em><tt>"</tt></td>
                   <td>is an optional attribute that specifies the path to the <strong>Pre-Filter</strong> stylesheet to be applied to this file. If this path is not specified as an absolute path, it is assumed to be relative to the XTF base installation directory (i.e., XTF_HOME.) Multiple pre-filters may be specified in a list; they should be separated by ";" or "," characters. The pre-filters will be applied in the order listed (e.g. the original file is sent to the first pre-filter; its output is sent to the second pre-filter, whose output is sent to the third, etc.) If this attribute is omitted, no pre-filter will be applied to the file.</td>
                 </tr>
                 <tr>
                   <td><tt>displayStyle="</tt><em>DocumentFormatterPath</em><tt>"</tt></td>
                   <td>is an optional attribute that specifies path to the <strong>Document Formatter</strong> stylesheet to use for this file. If this path is not specified as an absolute path, it is assumed to be relative to the XTF base installation directory (i.e., XTF_HOME.) If this attribute is present, the textIndexer will create a special cache that is used by the <strong><em>dynaXML</em></strong> servlet to display the current file more quickly. If this attribute is omitted, the cache is not created. For more details, see the discussion of <a>Lazy Document Handling</a> in the <a href="http://xtf.cdlib.org/documentation/under-the-hood/">XTF Under the Hood</a> guide.</td>
                 </tr>
               </tbody>
             </table>
          </li>
        </ul>
      </li>
    </ul>
    <h3><a name="preFilter">2. Pre-Filter</a></h3>
    <ul>
      <li><strong>Output Attributes</strong>
        <a name="preFilter_output"/>
        This section summarizes the attributes defined for the <strong>Pre-Filter</strong> stylesheet to output which have meaning for the textIndexer tool.
        <ul>
          <li><u>Index/No-index Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:index" select="'TrueOrFalse'"/&gt;
&lt;xsl:attribute name="xtf:noindex" select="'TrueOrFalse'"/&gt;</pre>
            This attribute is used to turn on/off indexing for a tag in a source document. The noindex variant is simply a logical inverse of the index variant. Both are provided as a convenience to the programmer.
            
            The value for either of these tags should be set to either the string '<tt>true</tt>' or the string '<tt>false</tt>'. (Note: If not explicitly set, nested sub-tags for a document inherit the index/noindex state from the closest parent tag for which an index state is defined.)
            
            This attribute can be used for normal text blocks, and also on blocks marked as metadata using the <tt>xtf:meta</tt> attribute below. In both cases, it controls whether the given block of text, or meta-data field, is added to the index. In the case of meta-data, a field that isn't added to the index will still be made available to the <strong>Result Formatter</strong> stylesheet when crossQuery results are displayed.
          </li>

          <li><u>Meta-Data Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:meta" select="'TrueOrFalse'"/&gt;</pre>
            This attribute is used to mark the contents of a tag as being part of the meta-data for a document rather than main-body text for the document.
            
            The select value for this tag should be set to either the string '<tt>true</tt>' (text in tag is meta data) or the string '<tt>false</tt>' (text in tag <strong>is not</strong> meta data.)
            
            The entire tag and its contents will be treated as meta-data and will be added to the index using the element name as the name of the meta-data field. That is, the tag will be indexed separately from the full text of the document.
            
            Other attributes of the tag, and any embedded element tags, will be stored in the index and will be passed verbatim to the <strong>Result Formatter</strong> stylesheet to be used for output purposes. Of course the text of the element and any sub-elements will be searchable, but the actual attributes and element tags themselves cannot be searched for.
            
            Note: If you mark a section of text with the <tt>xtf:meta</tt> attribute, it will <span class="underline">not</span> be included in the full text index of that document (accessed by querying the text field). If you want a given piece of text to appear in both the meta-data and full-text indexes, make two copies of it, marking one with <tt>xtf:meta</tt> and not marking the other.
          </li>
          
          <li><u>Store Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:store" select="'TrueOrFalse'"/&gt;</pre>
            This attribute is used to turn on/off whether to store the contents of a meta-data field in the index, and make them available to the <strong>Result Formatter</strong> stylesheet.
            
            The value for either of these tags should be set to either the string '<tt>true</tt>' or the string '<tt>false</tt>'. If not specified, this attribute defaults to '<tt>true</tt>'.
            
            This attribute can only be used on meta-data blocks that also have the <tt>xtf:meta</tt> attribute set. Setting xtf:store to '<tt>false</tt>' can make the final index smaller, and can also speed up processing by the <strong>Result Formatter</strong> stylesheet, since it will have less data to process. A field can be indexed and stored, indexed and not stored, or stored and not indexed; all of these combinations can be useful in certain circumstances.
          </li>
        
          <li><u>Tokenize Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:tokenize" select="'YesOrNo'"/&gt;</pre>
            This attribute is used to indicate whether a meta-data field should be tokenized or not. By default, meta-data fields are tokenized so they can be searched. If you intend to use a meta-data field for sorting query results instead, set this attribute to '<tt>no</tt>' .
          </li>
        
          <li><u>Proximity Break Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:proximitybreak" select="'TrueOrFalse'"/&gt;</pre>
            This attribute introduces a proximity break into a document. A tag marked with a proximity break attribute is considered to be infinitely far away from the previous or containing tag. Using this tag prevents proximity matches that span two adjacent tags from being counted as a valid match.
            
            The select value for this tag should be set to either the string '<tt>true</tt>' (introduce a proximity break) or the string '<tt>false</tt>' (<strong>do not</strong> introduce a proximity break.)
            
            To de-emphasize rather than disallow proximity matches across sections, use the sectionBump attribute instead (see below).
          </li>
        
          <li><u>Sentence Bump Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:sentenceBump" select="BumpInWords"/&gt;</pre>
            This attribute de-emphasizes proximity searches that span multiple sentences by introducing extra virtual spacing between adjacent sentences. The amount of virtual spacing to add between the end of the previous sentence and the beginning of the current one is specified as a number of virtual words by the BumpInWords argument. This value, if not specified, defaults to five words of added spacing.
            
            (Note: If not explicitly set, nested sub-tags for a document inherit the sentence bump value from the closest parent tag for which a sentence bump value is defined.)
          </li>
          <li><p id="tagRef_textIndexer_PreFilter_SectType"><u>Section Type Attribute</u></p>
            
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:sectionType" select="'TypeName'"/&gt;</pre>
            This attribute assigns a section type name to a tag, with the TypeName parameter identifying the section name to use. Assigning a section name to a tag allows grouped searches to be performed on tags that have the same section names, by inserting a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type Tag</a> into a query.
            
            (Note: If not explicitly set, nested sub-tags for a document inherit the section type name from the closest parent tag for which a section name is defined.)
          </li>
        
          <li><u>Section Type Add Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:sectionTypeAdd" select="'TypeName'"/&gt;</pre>
            This attribute appends a section type name to the section type already associated with a tag (or one of its ancestors which has a section type), with the TypeName parameter identifying the section name to append. Assigning a section name to a tag allows grouped searches to be performed on tags that have the same section names, by inserting a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type Tag</a> into a query. And appending a section type allows child tags to inherit their parent's <tt>sectionType</tt> and then add additional type information. This can be very useful for representing hierarchical information using section types.
            
            (Note: If not explicitly set, nested sub-tags for a document inherit the section type name from the closest parent tag for which a section name is defined, including any section type which has been appended to that parent tag.)
          </li>
        
          <li><u>Section Bump Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:sectionBump" select="BumpInWords"/&gt;</pre>
            This attribute de-emphasizes proximity searches that span multiple sections by introducing extra virtual spacing between adjacent sections. The amount of virtual spacing added between the end of the previous section and the beginning of the current one is specified as a number of virtual words by the BumpInWords argument. This value, if not specified, defaults to zero words of added spacing.
          </li>
          
          <li><u>Word Boost Attribute</u>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:attribute name="xtf:wordBoost" select="BoostValue"/&gt;</pre>
            This attribute boosts or de-emphasizes the relevance of text found within a particular tag. To boost the relevance of text in a tag, set the BoostValue parameter to a floating-point number greater than 1.0. To de-emphasis the relevance of a tag's text, set the BoostValue parameter to a floating-point number between 0.0 and 1.0.
            
            (Note: If not explicitly set, nested sub-tags for a document inherit the boost value from the closest parent tag for which a boost value is defined.)
          </li>
        </ul>
      </li>
    </ul>
    
    <!--CrossQuery tags-->
    <h2 style="border-bottom: medium double black;"><a name="crossQuery">crossQuery</a></h2>
    <a href="#top"><em>return to top</em></a>
    
    This section details the parameters, input tags, output tags, and utilities used in programming the <strong>crossQuery</strong> servlet.
    <h3><a name="common"></a>1. Common to crossQuery and dynaXML</h3>
    <ul>
      <li><strong>Stylesheet parameters</strong>
        This section summarizes the standard set of XSL parameters available to every stylesheet used by the <strong><em>crossQuery</em></strong> and <strong><em>dynaXML</em></strong> servlets. These include the original URL of the current request (in a few handy forms), the XTF base directory, and headers from the HTTP request.
        <ul>
          <li><u>Request URL</u>
            This field identifies the full URL passed to the XTF system for the current request. The request URL is always available to servlets (unlike many of the following parameters which are optional). It is accessed via the XSL parameter
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.URL"/&gt;</pre>
            This parameter contains a URL string of the form: <tt>http://</tt><em>yourserver</em><tt>/</tt><em>yourport</em><tt>/</tt><em>servlet</em><tt>/</tt><em>queryparms</em>
            
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><em>yourserver</em></td>
                  <td>is the name of your XTF server</td>
                </tr>
                <tr>
                  <td><em>yourport</em></td>
                  <td>is the port through which XTF requests are routed (typically 8080)</td>
                </tr>
                <tr>
                  <td><em>servlet</em></td>
                  <td>is the name of the servlet to which the request is being sent. Normally, this is either <tt>search</tt> (for crossQuery) or <tt>view</tt> (for dynaXML)</td>
                </tr>
                <tr>
                  <td><em>queryparms</em></td>
                  <td>is the list of parameters that defines the actual request being sent to the servlet. All URL escape codes (such as %20 for space) will have been translated to normal characters, and UTF-8 octet sequences will have been decoded.</td>
                </tr>
              </tbody>
            </table>
          </li>
          <li><u>Request URL with Original Unescaped Percent Codes</u>          
            <p>This field identifies the full URL passed to the XTF system for the current request, with all of the percent codes left unescaped. The request URL is always available to servlets (unlike many of the following parameters which are optional). It is accessed via the XSL parameter</p>
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.rawURL"/&gt;</pre>
            This parameter contains a URL string of the form: <tt>http://</tt><em>yourserver</em><tt>/</tt><em>yourport</em><tt>/</tt><em>servlet</em><tt>/</tt><em>queryparms</em>
            
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><em>yourserver</em></td>
                  <td>is the name of your XTF server</td>
                </tr>
                <tr>
                  <td><em>yourport</em></td>
                  <td>is the port through which XTF requests are routed (typically 8080)</td>
                </tr>
                <tr>
                  <td><em>servlet</em></td>
                  <td>is the name of the servlet to which the request is being sent. Normally, this is either <tt>search</tt> (for crossQuery) or <tt>view</tt> (for dynaXML)</td>
                </tr>
                <tr>
                  <td><em>queryparms</em></td>
                  <td>is the list of parameters that defines the actual request being sent to the servlet. All URL escape codes (such as %20 for space) will be left unescaped (i.e. <strong>not</strong> translated to normal characters) and UTF-8 octet sequences will <strong>not</strong> have been decoded.</td>
                </tr>
              </tbody>
            </table>

          </li>
          
          <li><u>Servlet Directory</u>
            
            This field identifies the filesystem path (directory) of the XTF instance in which the stylesheet is running. It is accessed via the XSL parameter
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="servlet.dir"/&gt;</pre>
            Typically this value comes from the servlet container (e.g. Resin or Tomcat), but may be overridden by specifying a base-dir parameter in the servlet container configuration. As this varies by container, check the documentation for your servlet container if you wish to override this value.
          </li>
        
          <li><u>Servlet URL</u>
            
            This field identifies the URL used to access the servlet. It is accessed via the XSL parameter
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="servlet.URL"/&gt;</pre>
            This parameter contains a URL string of the form: <tt>http://</tt><em>yourserver{</em>:<em>yourport}</em><tt>/</tt><em>xtf</em><tt>/</tt><em>servlet</em>
            
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><em>yourserver</em></td>
                  <td>is the name of your XTF server</td>
                </tr>
                <tr>
                  <td><em>yourport</em></td>
                  <td>is the port through which XTF requests are routed (typically 8080)</td>
                </tr>
                <tr>
                  <td><em>servlet</em></td>
                  <td>is the name of the servlet to which the request is being sent. Normally, this is either <tt>search</tt> (for crossQuery) or <tt>view</tt> (for dynaXML)</td>
                </tr>
              </tbody>
            </table>
            Note that the query string is <em>not</em> included in this parameter; if you need to access the query string, use the <strong>Request URL</strong> parameter above.
          </li>
        
          <li><u>Root URL</u>
            
            This field identifies the URL of this particular instance in the servlet container. The value is useful for accessing icons and other non-servlet resources from the container. It is accessed via the XSL parameter
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="root.URL"/&gt;</pre>
            This parameter contains a URL string of the form: <tt>http://</tt><em>yourserver{</em><tt>:</tt><em>yourport}</em><tt>/</tt><em>xtf</em><tt>/</tt>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><em>yourserver</em></td>
                  <td>is the name of your XTF server</td>
                </tr>
                <tr>
                  <td><em>yourport</em></td>
                  <td>is the port through which XTF requests are routed (typically 8080)</td>
                </tr>
              </tbody>
            </table>
            Note that the servlet name and query string are <em>not</em> included in this parameter; if you need to access these, use the <strong>Request URL</strong> parameter or the <strong>Servlet URL</strong> parameter, above.
          </li>
        
          <li><u>User-Agent Header Field</u>
            
            This optional HTTP header field identifies the browser that issued the current request. It is accessed via the XSL parameter
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.user-agent"/&gt;</pre>
            This parameter contains a string that identifies the browser that made the current request. Most HTTP requests will provide this field. For example:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt; empas)</pre>
            Note that the contents of this field vary widely depending on which browser made the request, and a detailed description is beyond the scope of this document.
          </li>
        
          <li><u>Referer Field</u>
            
            This optional HTTP header field identifies the web page from which the request URL was issued. It is accessed via the XSL parameter
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.referer"&gt;</pre>
            This parameter holds a URL string identifying the web page that issued the request. Often the initial request to the servlet will supply this parameter; subsequent requests will not.
          </li>
        
          <li><u>If-Modified-Since Header Field</u>
            
            This optional HTTP header field identifies the last time a particular request URL was issued by a browser. This field can be used by an XTF stylesheet to determine if a request needs to be processed because the XTF database has changed, or whether the requesting browser can use its previously cached results. This field is accessed via the XSL parameter
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.if-modified-since"/&gt;</pre>
            Most HTTP responses will not include this parameter, but if they do, the contents of this time string of the form:
            <em>weekday, dd-mmm-yy hh:mm:ss timezone</em>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><em>weekday</em></td>
                  <td>is the day of the week the request was last issued</td>
                </tr>
                <tr>
                  <td><em>dd-mmm-yy</em></td>
                  <td>is the day, three letter month abbreviation, and year the request was last issued</td>
                </tr>
                <tr>
                  <td><em>hh:mm:ss</em></td>
                  <td>is the time the request was last issued, represented as a 24 hour GMT based time</td>
                </tr>
                <tr>
                  <td><em>timezone</em></td>
                  <td>is the offset in hours of the timezone from which the request was last issued.</td>
                </tr>
              </tbody>
            </table>
          </li>
          
          <li><u>Other HTTP Headers</u>
            
            All HTTP header fields are made available to stylesheets in a similar fashion to the fields detailed above. In general they are accessed via XSL parameters like this:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.field-name"&gt;</pre>
            where field-name is the name of the HTTP header field. Note that most HTTP header fields will be absent most of the time.
          </li>
        
          <li><u>Pass-Through Configuration Parameters</u>
            
            Any unrecognized tag present in the configuration file for a given tool (i.e. <tt>textIndexer.conf</tt> for the textIndexer, <tt>dynaXML.conf</tt> for the dynaXML, etc.) will be made available to stylesheets run by that tool. These can be accessed by declaring an XSLT parameter containing the element name and the attribute name:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="ElementName.AttributeName/&gt;</pre>
            For a concrete example, see the <a class="wiki" href="http://xtf.cdlib.org/documentation/programming-guide/#common_pass">Programming Guide</a>.
          </li>
        </ul>
      </li>
      
      <li><strong>Parser Input Tags</strong>
        
        The following tags make up the XML input for the <strong>Query Router</strong>, <strong>Query Parser</strong>, and <strong>Document Request Parser</strong> stylesheets. They constitute a simple XML representation of the query URL supplied to the crossQuery or dynaXML servlet.
        
        <ul>
          <li><u>Container Tag</u>
            
            This tag is the outermost tag for the XML input fragment sent to the router or parser stylesheet for translation. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;parameters&gt;
    ParameterBlock
    ParameterBlock
    …
&lt;/parameters&gt;</pre>
          </li>
          
          <li><u>Parameter Block Tag</u>
            
            This tag is the XML input to the parser for a single parameter in a user query URL. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;param name="ParamName" value="ParamValue"&gt;
    Token | Phrase
    Token | Phrase
    …
&lt;/param&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>name=</tt>"ParamName"</td>
                  <td>is the name of the parameter extracted from the original query URL.</td>
                </tr>
                <tr>
                  <td><tt>value=</tt>"ParamValue"</td>
                  <td>is the original text in the query URL that is assigned to the specified parameter.</td>
                </tr>
              </tbody>
            </table>
            Note that each of the parameters from the query URL is also available as a standard XSL parameter with the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="ParamName" select="DefaultValueIfNotInURL"/&gt;</pre>
            This allows query parameters to be accessed either through the standard template driven XML or through stylesheet parameters.
          </li>
        
          <li><u>Token Tag</u>
            
            This tag identifies a single word or token taken from the query URL. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;token value="Word" isWord="YesOrNo"/&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>value=</tt>"Word"</td>
                  <td>is the actual word or symbol extracted from the URL.</td>
                </tr>
                <tr>
                  <td><tt>isWord=</tt>"YesOrNo"</td>
                  <td>identifies whether the token is a word (<tt>isWord="yes"</tt>) or a punctuation symbol (<tt>isWord="no"</tt>.)</td>
                </tr>
              </tbody>
            </table>
          </li>
          
          <li><u>Phrase Tag</u>
            
            This tag identifies a literal phrase taken from the query URL. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;phrase value="StringOfWords"&gt;
    Token
    Token
    …
&lt;/phrase&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>value=</tt>"StringOfWords"</td>
                  <td>is the entire phrase extracted from the URL as a single string.</td>
                </tr>
                <tr>
                  <td>Token, Token...</td>
                  <td>is the original phrase broken down into one or more <strong>Token Tags</strong> (see above), one for each word or symbol in the phrase.)</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
        
      <li><strong><a name="ErrorGenerator">Error Generator Stylesheet</a></strong>
        
        The purpose of the <strong>Error Generator</strong> stylesheet is to generate a web-page that displays user friendly messages when crossQuery or <strong><em>dynaXML</em></strong> errors occur. Since its output is simply HTML, the only tags that this reference section covers are the input XML tags passed to the <strong>Error Generator</strong> by the servlets.For convenience, all of the error information passed into the <strong>Error Generator</strong> stylesheet as XML tags is also available in the following XSLT parameters:
        
        <table border="1">
          <tbody>
            <tr>
              <td><tt>$exception</tt></td>
              <td>A string containing the name of the exception that occurred. This will be the name of one of the error/exception tags listed below (e.g., <tt>ExcessiveWork</tt>, <tt>TermLimit</tt>, etc.)</td>
            </tr>
            <tr>
              <td><tt>$message</tt></td>
              <td>The descriptive message for the error/exception (if any; may be an empty string.)</td>
            </tr>
            <tr>
              <td><tt>$stackTrace</tt></td>
              <td>The HTML-Formatted Java Stack Trace generated by the exception, (if any; may be an empty string.)</td>
            </tr>
          </tbody>
        </table>
        
        <br />
        
        <ul>
          <li>
            <em>Query Format Error Tag</em>
            <a name="ErrorGenerator_QueryFormat"></a>
            
            This error tag is issued by the <strong>Query Parser</strong> or <strong>Document Request Parser</strong> stylesheet if its code determines that there is an error in the query URL received from the user. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;QueryFormat&gt;
    &lt;message&gt;Error Message&lt;/message&gt;
&lt;/QueryFormat&gt;</pre>
            To generate such an error, the <strong>Query Parser</strong> simply issues a
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;error message="Error Message"/&gt;</pre>
            tag instead of a query tag. The error message specified by the parser's error tag is then transferred to the <strong>Query Format Error Tag</strong>, for processing by the servlet's <strong>Error Generator</strong> stylesheet.
          </li>
          
          <li><u><a name="ErrorGenerator_TermLimit"></a>Term Limit Error Tag</u>
            
            This error tag is issued by the <strong>Query Parser</strong> or <strong>Document Request Parser</strong> stylesheet if the number terms or clauses in a query exceeds the maximum term limit established by the <strong>termLimit</strong> attribute of the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag produced by the <a href="http://xtf.cdlib.org/documentation/programming-guide/#cross_query">Query Parser</a>. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;TermLimit&gt;
    &lt;message&gt;Error Message&lt;/message&gt;
&lt;/TermLimit&gt;</pre>
            This error is most often generated by the expansion of wildcard and range queries.
          </li>
          
          <li><u><a name="ErrorGenerator_ExcessiveWork"></a>Excessive Work Error Tag</u>
            
            This error tag is issued by the <strong>Query Parser</strong> or <strong>Document Request Parser</strong> stylesheet if a query exceeds the maximum work limit established by the <strong>workLimit</strong> attribute of the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag produced by the <a href="http://xtf.cdlib.org/documentation/programming-guide/#cross_query">Query Parser</a>. It has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;ExcessiveWork&gt;
    &lt;message&gt;Error Message&lt;/message&gt;
&lt;/ExcessiveWork&gt;</pre>
          </li>
          
          <li><u><a name="ErrorGenerator_InvalidDocument"></a>Invalid Document Error Tag</u>
            
            This error tag is issued by the dynaXML servlet if a document requested by the <strong>Document Request Parser</strong> stylesheet (in the <tt>&lt;source&gt;</tt> tag) cannot be located. This tag has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;InvalidDocument&gt;
    &lt;message&gt;Error Message&lt;/message&gt;
    &lt;docId&gt;Document Identifier&lt;/message&gt;
&lt;/InvalidDocument&gt;</pre>
            Usually, this error is generated when a request is made for a document that doesn't exist (for instance, it might have been removed, or the document ID might be invalid.)
          </li>
          
          <li><u><a name="ErrorGenerator_NoPermission"></a>No Permission Error Tag</u>
            
            This error tag is issued by the dynaXML servlet if the authentication (specified by the <strong>Document Request Parser</strong> stylesheet) fails for some reason. For instance, if IP-based authentication has been specified, and the requestor's IP address isn't in the IP list, this error will be issued. This tag has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;NoPermission&gt;
    &lt;message&gt;Error Message&lt;/message&gt;
    &lt;ipAddr&gt;IP Address&lt;/message&gt;
&lt;/NoPermission&gt;</pre>
            Note that the IP address will only be included for requests that failed during IP-list authentication (and not for LDAP or external authentication, for example.)
          </li>
          
          <li><u><a name="ErrorGenerator_UnsupportedQuery"></a>Unsupported Query Error Tag</u>
            
            This error tag is issued by the dynaXML servlet if a document request issued by the <strong>Document Request Parser</strong> stylesheet specifies a text query, and the document being queried is not present in the index. Searching can only be performed on documents that have been indexed. This tag has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;UnsupportedQuery&gt;
    &lt;message&gt;Error Message&lt;/message&gt;
&lt;/UnsupportedQuery&gt;</pre>
            Usually, this error is generated when a <a href="#tagRef_dynaXML_ReqParser_Output_Query">query</a> tag has been used in a document request without the required <a href="#tagRef_dynaXML_ReqParser_Output_Index">index</a> tag.
          </li>
          
          <li><u><a name="ErrorGenerator_GeneralException"></a>General Exception Error Tag</u>
            
            This error tag is generated whenever an internal exception occurs in any Servlet. This tag looks as follows:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;GeneralExceptionName&gt;
    &lt;message&gt;Error Message&lt;/message&gt;
    &lt;stackTrace&gt;HTML-Formatted Java Stack Trace&lt;/stackTrace&gt;
&lt;/GeneralExceptionName&gt;</pre>
            Exceptions are usually generated by anomalous fatal conditions like missing required files, corrupted indexes, files locked by other applications, or bugs in the XTF code itself.
          </li>
        </ul>
      </li>
      
      <li> <a name="commonUtils"></a><strong>Utilities</strong>
        
        The following utilities are available to <strong><em>dynaXML</em></strong> and <strong><em>crossQuery</em></strong> stylesheets:
        
        <ul>
          <li><u>Raw Dump Mode</u>
            
            The <tt><strong>raw</strong></tt> URL parameter can be helpful when debugging a <strong>Search Result Formatter</strong> or <strong>Document Hit Formatter</strong> stylesheet. When specified, the servlet (either crossQuery or dynaXML) will dump the formatter input directly to the browser, bypassing the formatter stylesheet. The raw dump can help in formulating templates to correctly format the final output.
            
            This parameter is added to a query URL, and has the form:
            <tt>http://</tt><em>yourserver{</em><tt>:</tt><em>yourport}</em><tt>/xtf/search?</tt><em>queryParameters</em><tt>;<strong>raw=</strong></tt><em>YesOrNo</em>
            
            or
            <tt>http://</tt><em>yourserver{</em><tt>:</tt><em>yourport}</em><tt>/xtf/view?</tt><em>viewParameters</em><tt>;<strong>raw=</strong></tt><em>YesOrNo</em>
            
            where
            <table border="1">
              <tbody>
                <tr>
                  <td>YesOrNo</td>
                  <td>specifies whether or not raw XML search results are sent to your browser. If set to <strong>yes</strong> , the formatter stylesheet is disabled for the query, and raw XML search results or marked up document contents are sent to your browser. If set to <strong>no</strong> , the XML is sent to the formatter stylesheet for processing, and its output in turn is sent to the browser. If this URL parameter is not specified, it defaults to no.</td>
                </tr>
              </tbody>
            </table>
          </li>
          
          <li><u>Session State</u>
        
            XTF is capable of tracking variables associated with a particular browsing session. This section details the functions available to any crossQuery or dynaXML stylesheet for storing and retrieving session data.
            <ul>
              <li><u>Store Session Data Function</u>This function can be called within a stylesheet to set a name/value pair in the session data, like this:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:value-of select="session:setData(Name, Value)"/&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>session:</tt></td>
                      <td>is a namespace prefix to differentiate this function from any other. The namespace URI for this prefix must be: <strong>java:org.cdlib.xtf.xslt.Session</strong>.</td>
                    </tr>
                    <tr>
                      <td>Name</td>
                      <td>specifies the name under which to store the value in the session data.</td>
                    </tr>
                    <tr>
                      <td>Value</td>
                      <td>specifies the particular value to store. It may be either a string, or a structured piece of XML with a single outer-level element (and any number of inner elements.)</td>
                    </tr>
                  </tbody>
                </table>
                This function searches the session data for a value with a matching name. If found, the old value is replaced with the specified one. If not found, a new name/value pair is added to the session data.
                
                Note that session tracking must be enabled in the servlet configuration file before calling session:setData; if it not, a runtime error will be generated and processing will stop. By default session tracking is enabled; see the <a href="http://xtf.cdlib.org/documentation/deployment-guide/">XTF Deployment Guide</a> for more information on enabling or disabling session tracking.
                
                Although this function is typically called within an <tt>&lt;xsl:value-of&gt;</tt> element, it does not return a value. The purpose of using the <tt>&lt;xsl:value-of&gt;</tt> element is to force the XSLT processor to execute the function instead of possibly optimizing out the call.
              </li>
              
              <li><u>Retrieve Session Data Function</u>
                
                This function can be called within a stylesheet to retrieve a value from the session data, like this:
                <pre class="wiki">&lt;xsl:variable name="Variable" select="session:getData(Name)"/&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td>Variable</td>
                      <td>specifies the name of an XSLT variable to create.</td>
                    </tr>
                    <tr>
                      <td><tt>session:</tt></td>
                      <td>is a namespace prefix to differentiate this function from any other. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.Session</tt></strong>.</td>
                    </tr>
                    <tr>
                      <td>Name</td>
                      <td>specifies the name to look up in the session data.</td>
                    </tr>
                  </tbody>
                </table>
                This function searches the session data for a value with a matching name and returns the value (in this case, assigning it to the given XSLT variable.) If not found, <tt>null</tt> is returned (i.e. empty string/empty sequence.)
                
                Note that if session tracking isn't enabled, <tt>null</tt> is always returned. By default session tracking is enabled; see the <a href="http://xtf.cdlib.org/documentation/deployment-guide/">XTF Deployment Guide</a> for more information on enabling or disabling session tracking.
              </li>
              
              <li><u>Get Session Identifier</u>
                
                This function can be called within a stylesheet to obtain the current session identifier string, like this:
                <pre class="wiki">&lt;xsl:variable name="sessionID" select="session:getID()"/&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>session:</tt></td>
                      <td>is a namespace prefix to differentiate this function from any other. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.Session</tt></strong>.</td>
                    </tr>
                  </tbody>
                </table>
                This function returns the unique identifier assigned by the servlet container (e.g. Resin or Tomcat) to the current user session.</li>
              <li><u>Check Enabled Status Function</u>This function can be called within a stylesheet to check whether session tracking is enabled, like this:
                <pre class="wiki">&lt;xsl:if test="session:isEnabled()"/&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>session:</tt></td>
                      <td>is a namespace prefix to differentiate this function from any other. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.Session</tt></strong>.</td>
                    </tr>
                  </tbody>
                </table>
                This function returns <tt>true</tt> if session tracking is enabled in the configuration file for the current servlet. It returns <tt>false</tt> if session tracking is not enabled. By default session tracking is enabled; see the <a href="http://xtf.cdlib.org/documentation/deployment-guide/">XTF Deployment Guide</a> for more information on enabling or disabling session tracking.</li>
              
              <li><u>Encode URL Function</u>
                
                This function can be called within a stylesheet to add the session ID to any URL created by the stylesheet, like this:
                <pre class="wiki">&lt;xsl:variable name="Variable" select="session:encodeURL(RawURL)"/&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td>Variable</td>
                      <td>specifies the name of an XSLT variable to create. This variable will contain the new, encoded, URL.</td>
                    </tr>
                    <tr>
                      <td><tt>session:</tt></td>
                      <td>is a namespace prefix to differentiate this function from any other. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.Session</tt></strong>.</td>
                    </tr>
                    <tr>
                      <td>RawURL</td>
                      <td>specifies an expression or other variable containing the URL to be encoded.</td>
                    </tr>
                  </tbody>
                </table>
                This function adds a session ID to the specified raw URL, if necessary. Generally session IDs are stored in cookies, but if the user has disabled cookies, URLs will have session IDs added to them. Note that if session tracking is disabled, the URL will be returned unchanged.</li>
              
              <li> <u>session:noCookie()</u>
                
                This extension function is used to determine if cookies are enabled in the user's browser.
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:if test="session:noCookie()"&gt;
    &lt;a href="javascript:alert('Cookies are disabled!')"&gt;
    Requires Cookie!
    &lt;/a&gt;
&lt;/xsl:if&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>session:</tt></td>
                      <td>is a namespace prefix to differentiate this function from any other. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.Session</tt></strong>.</td>
                    </tr>
                  </tbody>
                </table>
              </li>
            </ul>
          </li>

          <li><u>Calling Command-line Tools</u>
            
            The built-in <tt>exec</tt> extension element can be used in stylesheets to call external command-line tools. See the <a href="http://xtf.cdlib.org/documentation/programming-guide/">Programming Guide</a> for a description and examples.
            
            <p style="text-decoration: underline;">External Command Extension Element</p>
            This element can be used inside any XTF stylesheet to call a command-line program, like this:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;exec:run command  = "CommandName"
          {timeout = "Milliseconds"}
          xsl:extension-element-prefixes="exec"&gt;
          
    {&lt;exec:arg&gt;Argument1&lt;/exec:arg&gt;}
    {&lt;exec:arg&gt;Argument2&lt;/exec:arg&gt;}
    …
    
    {&lt;exec:input&gt;
         XmlOrString
     &lt;/exec:input&gt;}
          
&lt;/exec:run&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>exec:</tt></td>
                  <td>is a namespace prefix identifying this particular Saxon extension. The namespace URI for this prefix must be: <strong><tt>java:/org.cdlib.xtf.saxonExt.Exec</tt></strong>.</td>
                </tr>
                <tr>
                  <td><tt>command=</tt>"CommandName"</td>
                  <td>specifies the command-line program to run. In general, this should be an absolute path; if a relative path is given, it will be resolved in an undefined manner.</td>
                </tr>
                <tr>
                  <td><tt>timeout=</tt>"Milliseconds"</td>
                  <td>is an optional attribute setting an upper limit, in milliseconds, on the amount of time the external process will be given to finish its work. If this time is exceeded, the process will be forcibly terminated, an a Java exception will be thrown (which terminates stylesheet processing immediately.) If this attribute is not specified, the process will be allowed to run to completion no matter how long it takes.</td>
                </tr>
                <tr>
                  <td><tt>&lt;exec:arg&gt;</tt></td>
                  <td>is an optional sub-element that can be used repeatedly to specify command-line arguments to be passed to the program. Each argument should be specified in its own <tt>&lt;exec:arg&gt;</tt> element; in particular, pairs should usually be broken up. For example, to perform the command "<strong><tt>ls -al *</tt></strong>" one would specify two arguments, the first being "<strong><tt>-al</tt></strong>" and the second being "<strong><tt>*</tt></strong>".</td>
                </tr>
                <tr>
                  <td><tt>&lt;exec:input&gt;</tt></td>
                  <td>is an optional sub-element that specifies the input to be send to the external program (input will be sent to the process stdio stream). If the content of the exec:input element is XML data (for instance, a variable holding one or more elements) then the servlet will automatically serialize the data into standard XML format, with UTF-8 character encoding. If the content is not XML, the string will be sent to the tool verbatim.</td>
                </tr>
              </tbody>
            </table>
            This extension element calls an external command-line tool. Internally, this creates a new operating system process, and the servlet thread waits for that process to complete.
            If the exec:input element is specified, the entire string of input text (converted from XML to text if necessary) will be fed to the process' stdin stream.
            
            Output from the process' stdout stream will be collected, and the servlet checks if the data begins with an XML header. If so, the value of the exec:run element will be actual XML elements from the data. Otherwise, the value will be one long string, being an exact copy of the output from the external tool.
            
            If the process exits with a non-zero code (or the optional timeout is exceeded) then XTF will throw a Java exception, which causes the stylesheet execution to terminate immediately.
          </li>
          
          <li><u>File Utility Functions</u>
        
            XTF provides a number of functions that stylesheets can use to check attributes of a file in the local filesystem. See the <a href="http://xtf.cdlib.org/documentation/programming-guide/">XTF Programming Guide</a> for a description and examples.
            
            <ul>
              <li><u>File Existence Extension Function</u>
                
                This extension function can be used within a stylesheet to determine whether a particular file exists on the filesystem, like this:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:if test="FileUtils:exists(FilePath)"&gt;
    …
&lt;/xsl:if&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>FileUtils:</tt></td>
                      <td>is a namespace prefix identifying this set of Saxon extension functions. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.FileUtils</tt></strong>.</td>
                    </tr>
                    <tr>
                      <td>FilePath</td>
                      <td>specifies the relative or absolute path to the file in question. If a relative path is specified, it will be resolved in relation to the stylesheet that calls the function.</td>
                    </tr>
                  </tbody>
                </table>
                The extension function returns the boolean value true if the file is readable by the stylesheet, or false if not.
              </li>
              
              <li><u>File Length Function</u>
                
                This extension function can be used within a stylesheet to determine the length (in bytes) of a particular file exists on the filesystem, like this:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:variable name="myFileLen" select="FileUtils:length(FilePath)"&gt;
    …
&lt;/xsl:variable&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>FileUtils:</tt></td>
                      <td>is a namespace prefix identifying this set of Saxon extension functions. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.FileUtils</tt></strong>.</td>
                    </tr>
                    <tr>
                      <td>FilePath</td>
                      <td>specifies the relative or absolute path to the file in question. If a relative path is specified, it will be resolved in relation to the stylesheet that calls the function.</td>
                    </tr>
                  </tbody>
                </table>
                The extension function returns the length, in bytes, of the specified file, or -1 if the file cannot be read.
              </li>
              
              <li><u>File Modification Time Function</u>
                
                This extension function can be used within a stylesheet to find out when a particular file was last modified, like this:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:variable name="myModTime"
              select="FileUtils:lastModified(FilePath, DateFormat)"&gt;
    …
&lt;/xsl:variable&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>FileUtils:</tt></td>
                      <td>is a namespace prefix identifying this set of Saxon extension functions. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.FileUtils</tt></strong>.</td>
                    </tr>
                    <tr>
                      <td>FilePath</td>
                      <td>specifies the relative or absolute path to the file in question. If a relative path is specified, it will be resolved in relation to the stylesheet that calls the function.</td>
                    </tr>
                    <tr>
                      <td>DateFormat</td>
                      <td>is a string representing the format that the date and/or time should be returned in. This uses codes from Java's <a class="ext-link" href="http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html"><span class="icon">SimpleDateFormat</span></a> class such as <tt>yyyy-MM-dd:HH:mm:ss</tt>. <strong>Warning</strong>: "mm" and "MM" are different: the former is minutes, the latter is months.</td>
                    </tr>
                  </tbody>
                </table>
                The extension function returns a formatted version of the date and/or time (depending on format) that a given file was last modified. This can be useful for detecting which files are newer than others, processing all files newer than a certain date, etc.
              </li>
              
              <li><u>Current Date &amp; Time Function</u>
                
                This extension function can be used within a stylesheet to find out the current date and time known to the system, like this:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:variable name="myTime"
              select="FileUtils:curDateTime(DateFormat)"&gt;
    …              
&lt;/xsl:variable&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>FileUtils:</tt></td>
                      <td>is a namespace prefix identifying this set of Saxon extension functions. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.FileUtils</tt></strong>.</td>
                    </tr>
                    <tr>
                      <td>DateFormat</td>
                      <td>is a string representing the format that the date and/or time should be returned in. This uses codes from Java's <a class="ext-link" href="http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html"><span class="icon">SimpleDateFormat</span></a> class such as <tt>yyyy-MM-dd:HH:mm:ss</tt>. <strong>Warning</strong>: "mm" and "MM" are different: the former is minutes, the latter is months.</td>
                    </tr>
                  </tbody>
                </table>
                The extension function returns a formatted version of the current date and/or time (depending on format). This can be useful for constructing time-based queries, displaying the time or date on a result page, etc.</li>
              
              <li> <u>readXMLStub</u>
                
                This extension function provides an efficient way to determine the root element name, public ID, DTD URI, and namespace of the source document.
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:variable name="xmlStub"
              select="FileUtils:readXMLStub(FilePath)"&gt;
    …
&lt;/xsl:variable&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>FileUtils:</tt></td>
                      <td>is a namespace prefix identifying this set of Saxon extension functions. The namespace URI for this prefix must be: <strong><tt>java:org.cdlib.xtf.xslt.FileUtils</tt></strong>.</td>
                    </tr>
                    <tr>
                      <td>FilePath</td>
                      <td>specifies the relative or absolute path to the file in question. If a relative path is specified, it will be resolved in relation to the stylesheet that calls the function.</td>
                    </tr>
                  </tbody>
                </table>
                This can be very useful when trying to determine the type of document you are dealing with and which stylesheets to apply to it. <em>xsl:for-each</em> must be used to correctly set the context node for the functions used in creating the variables.
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:for-each select="FileUtils:readXMLStub($file)"&gt;
    &lt;xsl:variable name="rn" select="name(*[1])"/&gt;
    &lt;xsl:variable name="pid" select="unparsed-entity-public-id($rn)"/&gt;
    &lt;xsl:variable name="uri" select="unparsed-entity-uri($rn)"/&gt;
    &lt;xsl:variable name="ns" select="namespace-uri(*[1])"/&gt;
    &lt;xsl:if test="matches($rn,'^TEI') or
                  matches($pid,'TEI') or
                  matches($uri,'tei2\.dtd') or
                  matches($ns,'tei')"&gt;
        This must be a TEI document!...
    &lt;/xsl:if&gt;
    …
&lt;xsl:for-each&gt;</pre>
                In the example stylesheets you can see it in action in both the docSelector and docReqParser.</li>
            </ul>
          </li>
          
        <li><em>Redirecting to Another URL</em>
        
        XTF provides an extension element that immediately redirects the user's browser to a different URL, suppressing further processing of the formatting stylesheet. See the <a href="http://xtf.cdlib.org/documentation/programming-guide/">XTF Programming Guide</a> for a description and example.
          
          <u>HTTP Redirection Extension</u>
          
            This element can be used inside any parsing or formatting stylesheet in XTF like this:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;redirect:send url="TargetURL"
               xmlns:redirect="java:/org.cdlib.xtf.saxonExt.Redirect"
               xsl:extension-element-prefixes="redirect"/&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>url=</tt>"TargetURL"</td>
                  <td>is a required attribute specifying the URL that the user's browser should be redirected to. An absolute or relative URL may be specified. If relative, the URL will be resolved by the servlet container to an absolute URL.</td>
                </tr>
                <tr>
                  <td><tt>redirect:</tt></td>
                  <td>is a namespace prefix identifying this Saxon extension instruction. The namespace URI for this prefix must be: <strong><tt>java:/org.cdlib.xtf.saxonExt.Redirect</tt></strong> . In addition, it must be declared in the list of extension-element-prefixes for Saxon. The declarations are most easily done in-line as shown above.</td>
                </tr>
              </tbody>
            </table>
            This extension element causes an immediate HTTP redirect (code 302) to be sent to the user's browser. Further processing of the stylesheet is aborted.
            
            No prior output is allowed before this extension instruction is executed. If any output was generated, an exception will be thrown and the redirect will fail.
          </li>
          
          <li><em>TBD: Dynamic E-mail</em></li>
        
          <li><em>TBD: Tidying HTML Files</em></li>
        </ul>
      </li>
    </ul>
    
    <h3>Query Router and Query Parser Tags</h3>
    <ul>
      <li><a name="routerParserInputTagParameters">Common Input Tags and Parameters</a>
        <ul>
          <li><u>Common Parser Input Tags</u>
            
            The following tags make up the XML input for the Query Router, Query Parser, and Document Request Parser  stylesheets. They constitute a simple XML representation of the query URL supplied to the crossQuery or dynaXML servlet.
            <ul>
              
              <li><u>Container Tag</u>This tag is the outermost tag for the XML input fragment sent to the router or parser stylesheet for translation. It has the form:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;parameters&gt;
    ParameterBlock
    ParameterBlock
    …
&lt;/parameters&gt;</pre>
              </li>
              
              <li><u>Parameter Block Tag</u>This tag is the XML input to the parser for a single parameter in a user query URL. It has the form:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;param name="ParamName" value="ParamValue"&gt;
    Token | Phrase
    Token | Phrase
    …
&lt;/param&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>name=</tt>"ParamName"</td>
                      <td>is the name of the parameter extracted from the original query URL.</td>
                    </tr>
                    <tr>
                      <td><tt>value=</tt>"ParamValue"</td>
                      <td>is the original text in the query URL that is assigned to the specified parameter.</td>
                    </tr>
                  </tbody>
                </table>
                Note that each of the parameters from the query URL is also available as a standard XSL parameter with the form:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="ParamName" select="DefaultValueIfNotInURL"/&gt;</pre>
                This allows query parameters to be accessed either through the standard template driven XML or through stylesheet parameters.
              </li>
              
              <li><u>Token Tag</u>
                
                This tag identifies a single word or token taken from the query URL. It has the form:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;token value="Word" isWord="YesOrNo"/&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>value=</tt>"Word"</td>
                      <td>is the actual word or symbol extracted from the URL.</td>
                    </tr>
                    <tr>
                      <td><tt>isWord=</tt>"YesOrNo"</td>
                      <td>identifies whether the token is a word (<tt>isWord="yes"</tt>) or a punctuation symbol (<tt>isWord="no"</tt>.)</td>
                    </tr>
                  </tbody>
                </table>
              </li>
              
              <li><u>Phrase Tag</u>
                
                This tag identifies a literal phrase taken from the query URL. It has the form:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;phrase value="StringOfWords"&gt;
    Token
    Token
    …
&lt;/phrase&gt;</pre>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><tt>value=</tt>"StringOfWords"</td>
                      <td>is the entire phrase extracted from the URL as a single string.</td>
                    </tr>
                    <tr>
                      <td>Token, Token...</td>
                      <td>is the original phrase broken down into one or more <strong>Token Tags</strong> (see above), one for each word or symbol in the phrase.)</td>
                    </tr>
                  </tbody>
                </table>
              </li>
            </ul>
          </li>
          
          <li><em>Common Stylesheet Parameters</em>
            
            This section summarizes the standard set of XSL parameters available to every stylesheet used by the crossQuery and dynaXML  servlets. These include the original URL of the current request (in a few handy forms), the XTF base directory, and headers from the HTTP request.
            
            <ul>
              <li><u>Request URL</u>
                
                This field identifies the full URL passed to the XTF system for the current request. The request URL is always available to servlets (unlike many of the following parameters which are optional). It is accessed via the XSL parameter
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.URL"/&gt;</pre>
                This parameter contains a URL string of the form: <tt>http://</tt><em>yourserver</em><tt>/</tt><em>yourport</em><tt>/</tt><em>servlet</em><tt>/</tt><em>queryparms</em>
                
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><em>yourserver</em></td>
                      <td>is the name of your XTF server</td>
                    </tr>
                    <tr>
                      <td><em>yourport</em></td>
                      <td>is the port through which XTF requests are routed (typically 8080)</td>
                    </tr>
                    <tr>
                      <td><em>servlet</em></td>
                      <td>is the name of the servlet to which the request is being sent. Normally, this is either <tt>search</tt> (for crossQuery) or <tt>view</tt> (for dynaXML)</td>
                    </tr>
                    <tr>
                      <td><em>queryparms</em></td>
                      <td>is the list of parameters that defines the actual request being sent to the servlet. All URL escape codes (such as %20 for space) will have been translated to normal characters, and UTF-8 octet sequences will have been decoded.</td>
                    </tr>
                  </tbody>
                </table>
              </li>
              
              <li><u>Servlet Directory</u>
                
                This field identifies the filesystem path (directory) of the XTF instance in which the stylesheet is running. It is accessed via the XSL parameter
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="servlet.dir"/&gt;</pre>
                Typically this value comes from the servlet container (e.g. Resin or Tomcat), but may be overridden by specifying a base-dir parameter in the servlet container configuration. As this varies by container, check the documentation for your servlet container if you wish to override this value.
              </li>
              
              <li><u>Servlet URL</u>
                
                This field identifies the URL used to access the servlet. It is accessed via the XSL parameter
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="servlet.URL"/&gt;</pre>
                This parameter contains a URL string of the form: <tt>http://</tt><em>yourserver{</em>:<em>yourport}</em><tt>/</tt><em>xtf</em><tt>/</tt><em>servlet</em>
                
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><em>yourserver</em></td>
                      <td>is the name of your XTF server</td>
                    </tr>
                    <tr>
                      <td><em>yourport</em></td>
                      <td>is the port through which XTF requests are routed (typically 8080)</td>
                    </tr>
                    <tr>
                      <td><em>servlet</em></td>
                      <td>is the name of the servlet to which the request is being sent. Normally, this is either <tt>search</tt> (for crossQuery) or <tt>view</tt> (for dynaXML)</td>
                    </tr>
                  </tbody>
                </table>
                Note that the query string is <em>not</em> included in this parameter; if you need to access the query string, use the <strong>Request URL</strong> parameter above.
              </li>
              
              <li><u>Root URL</u>
                
                This field identifies the URL of this particular instance in the servlet container. The value is useful for accessing icons and other non-servlet resources from the container. It is accessed via the XSL parameter
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="root.URL"/&gt;</pre>
                This parameter contains a URL string of the form: <tt>http://</tt><em>yourserver{</em><tt>:</tt><em>yourport}</em><tt>/</tt><em>xtf</em><tt>/</tt>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><em>yourserver</em></td>
                      <td>is the name of your XTF server</td>
                    </tr>
                    <tr>
                      <td><em>yourport</em></td>
                      <td>is the port through which XTF requests are routed (typically 8080)</td>
                    </tr>
                  </tbody>
                </table>
                Note that the servlet name and query string are <em>not</em> included in this parameter; if you need to access these, use the <strong>Request URL</strong> parameter or the <strong>Servlet URL</strong> parameter, above.</li>
              <li><u>User-Agent Header Field</u>This optional HTTP header field identifies the browser that issued the current request. It is accessed via the XSL parameter
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.user-agent"/&gt;</pre>
                This parameter contains a string that identifies the browser that made the current request. Most HTTP requests will provide this field. For example:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt; empas)</pre>
                Note that the contents of this field vary widely depending on which browser made the request, and a detailed description is beyond the scope of this document.</li>
              <li><u>Referer Field</u>This optional HTTP header field identifies the web page from which the request URL was issued. It is accessed via the XSL parameter
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.referer"&gt;</pre>
                This parameter holds a URL string identifying the web page that issued the request. Often the initial request to the servlet will supply this parameter; subsequent requests will not.</li>
              <li><u>If-Modified-Since Header Field</u>This optional HTTP header field identifies the last time a particular request URL was issued by a browser. This field can be used by an XTF stylesheet to determine if a request needs to be processed because the XTF database has changed, or whether the requesting browser can use its previously cached results. This field is accessed via the XSL parameter
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.if-modified-since"/&gt;</pre>
                Most HTTP responses will not include this parameter, but if they do, the contents of this time string of the form:
                <em>weekday, dd-mmm-yy hh:mm:ss timezone</em>
                where
                <table border="1">
                  <tbody>
                    <tr>
                      <td><em>weekday</em></td>
                      <td>is the day of the week the request was last issued</td>
                    </tr>
                    <tr>
                      <td><em>dd-mmm-yy</em></td>
                      <td>is the day, three letter month abbreviation, and year the request was last issued</td>
                    </tr>
                    <tr>
                      <td><em>hh:mm:ss</em></td>
                      <td>is the time the request was last issued, represented as a 24 hour GMT based time</td>
                    </tr>
                    <tr>
                      <td><em>timezone</em></td>
                      <td>is the offset in hours of the timezone from which the request was last issued.</td>
                    </tr>
                  </tbody>
                </table>
              </li>
              
              <li><u>Other HTTP Headers</u>
                
                All HTTP header fields are made available to stylesheets in a similar fashion to the fields detailed above. In general they are accessed via XSL parameters like this:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="http.field-name"&gt;</pre>
                where field-name is the name of the HTTP header field. Note that most HTTP header fields will be absent most of the time.</li>
              <li><u>Pass-Through Configuration Parameters</u>Any unrecognized tag present in the configuration file for a given tool (i.e. <tt>textIndexer.conf</tt> for the textIndexer, <tt>dynaXML.conf</tt> for the dynaXML, etc.) will be made available to stylesheets run by that tool. These can be accessed by declaring an XSLT parameter containing the element name and the attribute name:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xsl:param name="ElementName.AttributeName/&gt;</pre>
                For a concrete example, see the <a href="http://xtf.cdlib.org/documentation/programming-guide/">Programming Guide</a>.</li>
            </ul>
          </li>
        </ul>
      </li>
      
      <li><em>Query Router tags</em>
        
        The tags listed here are XML tags associated with the Query Router stylesheet. The tags are divided into two categories: input tags (here) and then  <a href="#routerOutputTags">output tags</a>. The input tags are used by the crossQuery Servlet to translate the original query URL into a simple XML representation that can act as input to the Query Router stylesheet. The output tags are then used by the Query Router stylesheet to form the actual XML query passed to the crossQuery servlet's Text Search Engine for processing.
        
        The XML input to the Query Router stylesheet is a simple XML representation of the query URL supplied to the crossQuery servlet from the user query web-page. The XML input and XSL parameters are the same as those for the Query Parser and Document Request Parser.
        <ul>
          <li><a name="routerOutputTags"><em>Query Router Output Tags</em></a>
            
            These tags are used by the Query Router stylesheet to form the XML response telling the crossQuery servlet the particular query parser stylesheet to use. The top-level tag is the Route Tag below.
            
            <ul>
              <li><u><a name="crossQuery_QueryRouter_Output_Route">Route Tag</a></u>
                
                 This tag is outermost tag in the query route sent to the crossQuery servlet's query routing logic. It has the form:
                 <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;route&gt;
              
    QueryParserTag
    {ErrorGenTag}
          
&lt;/route&gt;</pre>
                 The <strong>QueryParserTag</strong> (see below) specified within this tag identifies the Query Parser stylesheet to use. If specified, the <strong>ErrorGenTag</strong> (see below) identifies an Error Generator stylesheet to use instead of the default specified in the crossQuery.conf file.
              </li>
              
              <li><u>QueryParser Tag</u>
                
                This tag appears directly within a <strong>Route Tag</strong> (see above). It has the form:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;queryParser path="QueryParserLocation"/&gt;</pre>
                This tag identifies which Query Parser stylesheet should be utilized by crossQuery to parse the URL parameters and produce an XTF query. If this path is not specified as an absolute path, it is assumed to be relative to the XTF base installation directory (i.e., XTF_HOME.)
              </li>
              
              <li><u>ErrorGen Tag</u>
                
                This tag appears directly within a <strong>Route Tag</strong> (see above). It has the form:
                <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;errorGen path="ErrorGeneratorLocation"/&gt;</pre>
                This tag identifies which stylesheet should be used in case unexpected errors occur during query parsing or processing. This overrides the default error generator specified in the crossQuery.conf configuration file. If this path is not specified as an absolute path, it is assumed to be relative to the XTF base installation directory (i.e., XTF_HOME.)
              </li>
            </ul>
          </li>
        </ul>
      </li>
      
      <li>
        <a name="parserOutputTags">Query Parser Output Tags</a>
        
        The tags listed here are XML tags associated with the Query Parser stylesheet. The tags are divided into two categories: output tags (on this page) and input tags. The input tags are used by the crossQuery Servlet to translate the original query URL into a simple XML representation that can act as input to the Query Parser stylesheet.The following output tags are used by the Query Parser stylesheet to form the XML query passed to the crossQuery search engine for processing. Since there are so many, each tag has its own page. The top-level tag is the &lt;query&gt; tag below.
        
        <blockquote><a href="#tagRef_crossQuery_QueryParser_Output_Query">&lt;query&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Error">&lt;error&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Term">&lt;term&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">&lt;phrase&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Exact">&lt;exact&gt;</a>
          
          <a href="#tagRef_crossQuery_QueryParser_Output_And">&lt;and&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Or">&lt;or&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">&lt;orNear&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Not">&lt;not&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Near">&lt;near&gt;</a>
          
          <a href="#tagRef_crossQuery_QueryParser_Output_Range">&lt;range&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">&lt;sectionType&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Facet">&lt;facet&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_Spellcheck">&lt;spellcheck&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">&lt;resultData&gt;</a>
          
          <a href="#tagRef_crossQuery_QueryParser_Output_MoreLike">&lt;moreLike&gt;</a>
          <a href="#tagRef_crossQuery_QueryParser_Output_allDocs">&lt;allDocs&gt;</a></blockquote>
        
        <ul>
          <li><u>Query Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Query">&lt;query&gt;</a>
              
              This tag is outermost tag in an XML query sent to the crossQuery servlet's search engine. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;query indexPath        = "IndexDBLocation"
       style            = "ResultFormatterLocation"
       {sortDocsBy      = "ListOfMetaFields|score"}
       {startDoc        = "FirstDocToReturn"}
       {maxDocs         = "MaxDocsToReturn"}
       {termLimit       = "MaxTermsToAllow"}
       {workLimit       = "MaxWorkToAllow"}
       {maxContext      = "MaxContextChars"}
       {maxSnippets     = "SnippetsToOutput"}
       {termMode        = "TermMarkMode"}
       {field           = "FieldToSearch"}
       {normalizeScores = "TrueOrFalse"}
       {explainScores   = "TrueOrFalse"}&gt;
        
       QueryElement
            
&lt;/query&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>indexPath="</tt><em>IndexDBLocation</em><tt>"</tt></td>
                    <td>is the path to the <strong>Index Database</strong> to use when performing the search. If this path is not specified as an absolute path, it is assumed to be relative to the XTF base installation directory (i.e., XTF_HOME.)</td>
                  </tr>
                  <tr>
                    <td><tt>style="</tt><em>ResultFormatterLocation</em><tt>"</tt></td>
                    <td>is the path to the <strong>Result Formatter</strong> stylesheet to use to display the results generated by the current query. If this path is not specified as an absolute path, it is assumed to be relative to the XTF base installation directory (i.e., XTF_HOME.)</td>
                  </tr>
                  <tr>
                    <td><tt>sortDocsBy="</tt><em>ListOfMetaFields|score</em><tt>"</tt></td>
                    <td>is an optional attribute specifying a list of meta fields by which to sort the results. The list should consist of a quoted string containing one or more meta-field names, separated by commas. If multiple meta-fields are specified, the results are sorted first by the left-most meta-field, then sub-sorted by subsequent fields to produce the final output. Optionally, each meta-field name can be preceded by a plus sign (<strong>+</strong>) or a minus sign (<strong>-</strong>) to indicate whether the results for that field should be sorted in ascending or descending order. If no plus or minus sign is specified for a meta-field, then the results are sorted in ascending order by default. If this attribute not specified, documents are by default sorted in order of decreasing score (so the most "relevant" documents are first.)  With XTF 3.0, this default behavior can now also be explicitly set by providing a value of "score" (or synonym “relevance”). (Note: Meta tags to be used for sorting queries should also have an xtf:tokenize="no" attribute set, or sorting will produce unpredictable results.) (Compatibility note: This attribute was previously called "sortMetaFields", and this old name is still accepted to retain backward compatibility.)</td>
                  </tr>
                  <tr>
                    <td><tt>startDoc="</tt><em>FirstDocToReturn</em><tt>"</tt></td>
                    <td>is an optional attribute specifying the ordinal number of the first matching document to pass on to the <strong>Result Formatter</strong>. If not specified, this attribute defaults to 1, meaning the first document that contains matches for the specified query.</td>
                  </tr>
                  <tr>
                    <td><tt>maxDocs="</tt><em>MaxDocsToReturn</em><tt>"</tt></td>
                    <td>is an optional attribute specifying the number of matching documents to pass on to the <strong>Result Formatter</strong>. If not specified, this attribute defaults to 10, meaning that up to 10 documents with matches will be returned for the specified query. The special value "<strong><tt>all</tt></strong>" may be used to indicate that <em>all</em> matching documents should be returned.</td>
                  </tr>
                  <tr>
                    <td><tt>termLimit="</tt><em>MaxTermsToAllow</em><tt>"</tt></td>
                    <td>is an optional attribute that limits the number of terms permitted in a query. If not specified, this attribute defaults to 50.  This attribute is used primarily to prevent wildcard expansions like <tt>&lt;term&gt;a*&lt;/term&gt;</tt> from overloading the crossQuery servlet. If the query does in fact exceed the limit specified by this attribute, a <a href="#ErrorGenerator_TermLimit">TermLimit</a> error is sent to the <strong>Error Generator</strong> stylesheet for the offending query.</td>
                  </tr>
                  <tr>
                    <td><tt>workLimit="</tt><em>MaxWorkToAllow</em><tt>"</tt></td>
                    <td>is an optional attribute that limits the amount of "work" that may be performed in a query. If not specified, this attribute defaults to -1, meaning no limit is enforced. This attribute is used primarily to prevent queries from overloading the crossQuery servlet, which would adversely impact the responsiveness of the XTF system. If a query exceeds the work limit set by this attribute, a <a href="#ErrorGenerator_ExcessiveWork">ExcessiveWork</a> error is sent to the <strong>Error Generator</strong> stylesheet for the offending query. For the crossQuery servlet, one unit of "work" is equivalent to finding a single matching term in a single document. Experimentally, a value of 500,000 for this attribute seems to work well.</td>
                  </tr>
                  <tr>
                    <td><tt>maxContext="</tt><em>MaxContextChars</em><tt>"</tt></td>
                    <td>identifies the size of a snippet to pass in the <strong>Result Formatter</strong> <a href="#tagRef_crossQuery_ResultFormatter_Snippet">snippet</a> tag. If not specified, this attribute defaults to 80 characters. Note that the context length is the total number of characters for the snippet, which includes both the matched text and the context text surrounding it.</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets="</tt><em>SnippetsToOutput</em><tt>"</tt></td>
                    <td>identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute. If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Note that -1 is a special value. If maxSnippets is set to -1, it requests that <em>all</em> snippets for a document be returned. If the maxSnippets attribute is set by the <tt>&lt;query&gt;</tt> tag, any occurrences of the maxSnippets attribute set by the inner tags must match the value set by the <tt>&lt;query&gt;</tt> tag. Otherwise, an error will be generated. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>termMode="</tt><em>TermMarkMode</em><tt>"</tt></td>
                    <td>is an optional parameter that specifies how terms should be marked in the search results. Valid values for this option are: <strong><tt>"none"</tt></strong>: Do not mark matching terms anywhere in the search results. <strong><tt>"hits"</tt></strong>: Mark matching terms in the search results only if they appear inside <tt>&lt;hit&gt;</tt> tags. <strong><tt>"context"</tt></strong>: Mark matching terms in the search results only if they appear inside <tt>&lt;snippet&gt;</tt> or <tt>&lt;hit&gt;</tt> tags. <strong><tt>"all"</tt></strong>: Mark matching terms in search results anywhere they occur. If not specified, the default value used is "hits". Note that when term marking is enabled, matching terms in the search results are placed inside <tt>&lt;term&gt;</tt> ... <tt>&lt;/term&gt;</tt> tag sets.</td>
                  </tr>
                  <tr>
                    <td><tt>field="</tt><em>FieldToSearch</em><tt>"</tt></td>
                    <td>is an optional parameter that identifies which field in the index to search. This can be set to <tt>text</tt> to indicate that the main text of the document should be searched, or it can name a meta-data field such as <tt>creator</tt> or <tt>subject</tt>. If child elements specify their own <tt>field</tt> attributes, their field name must agree with the parent element. (Note: Allowing nested copies of the field attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost field name is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>normalizeScores="</tt><em>TrueOrFalse</em><tt>"</tt></td>
                    <td>is an optional parameter that can disable <em>score normalization</em>, the process that converts all document scores to be relative to the highest ranking document (which receives a score of 100). If set to no or false, the scores will be raw floating point numbers. The default, true or yes, will normalize scores to the range of 0..100, and round them to whole numbers. In the default XTF stylesheets, one can simply add "<tt>;normalizeScores=1</tt>" to the query URL, and the default <strong>Query Parser</strong> will set this attribute for you.</td>
                  </tr>
                  <tr>
                    <td><tt>explainScores="</tt><em>TrueOrFalse</em><tt>"</tt></td>
                    <td>is an optional parameter that causes XTF to output a structured, detailed explanation of how the score for each document was calculated. This means that each <a href="#tagRef_crossQuery_ResultFormatter_DocHit">Document Hit Tag</a> in the query result will contain an <a href="#tagRef_crossQuery_ResultFormatter_Explanation">Score Explanation Tag</a>, which in turn contains other <a class="wiki" href="#tagRef_crossQuery_ResultFormatter_Explanation">Score Explanation Tags</a> describing how the components of that score. In the default XTF stylesheets, one can simply add "<tt>;explainScores=1</tt>" to the query URL, and the default <strong>Query Parser</strong> will set this attribute for you. This is an advanced feature, as XTF's scoring is fairly complex and can be confusing to those just starting out. For an overview of how XTF scores document hits, see the Scoring section of the document <a href="http://xtf.cdlib.org/documentation/under-the-hood/">XTF Under the Hood</a>. Note that if you enable this attribute, you should generally disable normalizeScores above, as the score explanations describe the non-normalized score for each document.</td>
                  </tr>
                </tbody>
              </table>
              The primary purpose of the startDoc and maxDocs attributes is to allow search results to be split up into multiple pages by the <strong>Result Formatter</strong>. For example, to display the second page of 50 matching documents, the following query tag could be generated by a link on the current result page:
              <pre style="background-color: #f0f0f0; border: 1px solid black;"> &lt;query … startDoc="51" maxDocs="50"&gt;
            …
&lt;/query&gt;</pre>
              The QueryElement specified within this tag identifies the query to be performed. This can be a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> query tag, or a <a class="wiki" href="tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a>, <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Spellcheck">spellcheck</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag.
              
              Note that the <strong>Query Parser</strong> stylesheet can issue a single top-level <a href="#tagRef_crossQuery_QueryParser_Output_Error">error</a> tag instead of a query tag if it encounters any errors.    
          </li>
          
          <li><u>Error Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Error">&lt;error&gt;</a>
              
              This tag can be issued by the <strong>Query Parser</strong> when it encounters an error. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;error message="Error Message"/&gt;</pre>
              where Error Message is an error string describing the error.
              
              This tag is a top level tag, and should be issued by itself in place of the normal <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag when an error occurs. Once issued, the error will be routed to the <strong><a href="programming_Common_ErrorGen">Error Generator</a></strong> stylesheet for processing.
          </li>
          
          <li><u>Term Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Term">&lt;term&gt;</a>
           
            This tag specifies a single word to search for. This tag has the form:
            <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;term {field       = "FieldName"}
      {maxSnippets = "SnippetsToOutput"}
      {boost       = "BoostValue"}&gt;
      
    WordToFind
      
    {OptionalSectionTypeQuery}
      
&lt;/term&gt;</pre>
            where
            <table border="1">
              <tbody>
                <tr>
                  <td><tt>field=</tt>"FieldName"</td>
                  <td>is an optional attribute that identifies which field in the index to search. Often this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that the field name specified by a <tt>&lt;term&gt;</tt> tag must match the field name set by any tags that contain it. Otherwise, an error will be generated.</td>
                </tr>
                <tr>
                  <td><tt>maxSnippets=</tt>"SnippetsToOutput"</td>
                  <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute. If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, the maxSnippets specified by a <tt>&lt;term&gt;</tt> tag must match the value set by any tags that contain it. Otherwise, an error will be generated.</td>
                </tr>
                <tr>
                  <td><tt>boost=</tt>"BoostValue"</td>
                  <td>is an optional attribute that specifies a relevance boost multiplier for this term in the query. Boost values higher than 1.0 increase the relevance of a term, while boost values between 0.0 and 1.0 decrease the relevance of a term. Boost values less than zero will generate an error.</td>
                </tr>
              </tbody>
            </table>
            Note that aside from letters and numbers, only a few select symbols may appear in WordToFind (e.g., apostrophes, periods as part of decimal numbers, etc.) If any other symbols appear in the word to find, no matches will be found in the index. This is because the indexer removes all other types symbols from a term before indexing it. For a complete list of symbols that may appear in a term, see the <a href="http://xtf.cdlib.org/documentation/under-the-hood/">XTF Under the Hood</a> guide.
            
            Also, the term tag is case-insensitive, so matches with capitalization different from that given in WordToFind may appear in the resulting list of matches.
            
            (Note: Any non-leading or trailing whitespace characters in WordToFind (i.e, space, tab, carriage-return, linefeed, etc.) will produce unpredictable search results.)
            
            If the field is <tt>"text"</tt>, a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type</a> sub-query may optionally appear, restricting this term query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>Phrase Search Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Phrase">&lt;phrase&gt;</a>
              
              This tag specifies a phrase for which to search. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;phrase {field       = "FieldName"}
        {maxSnippets = "SnippetsToOutput"}
        {boost       = "BoostValue"}&gt;
        
    Term | Clause
    Term | Clause
    …
        
    {OptionalSectionTypeQuery}
        
&lt;/phrase&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is an optional attribute that identifies which field in the index to search. Often this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that the field name specified by a <tt>&lt;phrase&gt;</tt> tag must match the field name set by any tags that contain it. Otherwise, an error will be generated. If no parent tags specify a field name, any field name can be used by the <tt>&lt;phrase&gt;</tt> tag. Similarly, any tags within a <tt>&lt;phrase&gt;</tt> tag must either specify the same field name as the phrase, or specify no field name at all. Otherwise, an error will be generated. (Note: Allowing nested copies of the field attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost field value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets=</tt>"SnippetsToOutput"</td>
                    <td>identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute.   If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, any maxSnippets value set by the <tt>&lt;phrase&gt;</tt> tag must match the value set by any tags that contain it. Otherwise, an error will be generated. If no parent tags set a maxSnippets value, then any value may be specified by the <tt>&lt;phrase&gt;</tt> tag. Similarly, any tags within a <tt>&lt;phrase&gt;</tt> tag must either specify the same field name as the phrase, or specify no field name at all. Otherwise, an error will be generated. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost=</tt>"BoostValue"</td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this phrase in the query. Boost values higher than 1.0 increase the relevance of a phrase, while boost values between 0.0 and 1.0 decrease the relevance of a phrase. Boost values less than zero will generate an error. Note that boost values multiply. That is, if tags within a <tt>&lt;phrase&gt;</tt> tag have boost attributes, their individual boost values will be multiplied by the boost set for the containing <tt>&lt;phrase&gt;</tt> tag.</td>
                  </tr>
                </tbody>
              </table>
              Within the phrase tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag.
              
              Note that text will only match a phrase query if all the terms in the phrase tag appear in the document in same order, with no other intervening words. Note that it does not matter whether the phrase appears at the beginning, middle, or end of a field; it will match in any position. To match the exact contents of an entire field, use the <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a> tag.
              
              If the field is "text", a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type</a> sub-query may optionally appear, restricting this phrase query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>Exact Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Exact">&lt;exact&gt;</a>
              
              This tag specifies an exact phrase to search for. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;exact {field       = "FieldName"}
       {maxSnippets = "SnippetsToOutput"}
       {boost       = "BoostValue"}&gt;
        
    Term | Clause
    Term | Clause
    …
    
    {OptionalSectionTypeQuery}
        
&lt;/exact&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is an optional attribute that identifies which field in the index to search. Normally, this attribute is set to the name of a meta field such as author or subject. It may not be set to text. It should be mentioned that the field name specified by a <tt>&lt;exact&gt;</tt> tag must match the field name set by any tags that contain it. Otherwise, an error will be generated. If no parent tags specify a field name, any field name can be used by the <tt>&lt;exact&gt;</tt> tag. Similarly, any tags within an <tt>&lt;exact&gt;</tt> tag must either specify the same field name as the phrase, or specify no field name at all. Otherwise, an error will be generated. (Note: Allowing nested copies of the field attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost field value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets=</tt>"SnippetsToOutput"</td>
                    <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute.   If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, any maxSnippets value set by the <tt>&lt;exact&gt;</tt> tag must match the value set by any tags that contain it. Otherwise, an error will be generated. If no parent tags set a maxSnippets value, then any value may be specified by the <tt>&lt;exact&gt;</tt> tag. Similarly, any tags within a <tt>&lt;exact&gt;</tt> tag must either specify the same field name as the phrase, or specify no field name at all. Otherwise, an error will be generated. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost=</tt>"BoostValue"</td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this phrase in the query. Boost values higher than 1.0 increase the relevance of a phrase, while boost values between 0.0 and 1.0 decrease the relevance of a phrase. Boost values less than zero will generate an error. Note that boost values multiply. That is, if tags within an <tt>&lt;exact&gt;</tt> tag have boost attributes, their individual boost values will be multiplied by the boost set for the containing <tt>&lt;exact&gt;</tt> tag.</td>
                  </tr>
                </tbody>
              </table>
              Within the exact tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag.
              
              Note that text will only match a exact query if all the terms in the exact tag appear in the document in same order, with no other intervening words. In addition, the match must begin at the start of the field and end at the end of the field (in other words, it must match the entire field.)
              
              For example, an exact search for "man on the moon" would not match field contents"put a man on the moon", nor would it match "man on the moon base". Only a field whose contents are exactly the string "man on the moon" (and nothing else) will match.
              
              Note that "exact"-ness refers only to the lack of other terms before and after the match; the normal rules for upper/lower case insensitivity, and accent/plural mapping still apply. So "man on the moon" will still match "Men on the MOON".
              
              If the field is "text", a &lt; a href="#tagRef_crossQuery_QueryParser_Output_SectionType"&gt;Section Type sub-query may optionally appear, restricting this query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>And Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_And">&lt;and&gt;</a>
              
              This tag defines a search where all of the sub-terms or clauses <em>must</em> exist in a document for a match to be made.
              
              If a single field is specified (using the <tt>field</tt> attribute), documents will match if <em>all</em> of the sub-terms or clauses occur in that field. If <tt>useProximity</tt> is "yes" (the default), then documents with terms closer together and in the right order will score higher than those in which the terms are farther apart.
              
              If multiple fields are specified (using the <tt>fields</tt> attribute), documents will match if <em>all</em> of the search terms occurs in <em>any</em> of the listed fields. That is, that is, it doesn't matter which field(s) they appear in, as long as all of them appear somewhere. If in one document multiple terms appear in the same field, the score will be higher, and if the terms are close together, the score will be higher still.
              
              This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;and {field        = "FieldName" |
      fields       = "Field1,Field2,..."}
     {maxSnippets  = "SnippetsToOutput"}
     {boost        = "BoostValue"}
     {useProximity = "YesOrNo"}&gt;
            
    Term | Clause
    Term | Clause
    …
    
    {OptionalSectionTypeQuery}
            
&lt;/and&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>field="</tt><em>FieldName</em><tt>"</tt></td>
                    <td>is an optional attribute that identifies which field in the index to search. Often this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that if the field attribute appears in any tags outside it, the field name in the <tt>&lt;and&gt;</tt> tag <strong><em>must</em></strong> match the value set in the outer tags. Otherwise, an error will be generated. However, if the <tt>&lt;and&gt;</tt> tag does not specify a field name, and no tags outside it specify a field name, then the tags directly below the <tt>&lt;and&gt;</tt> tag may have any combination of field names desired. This is how mixed queries of document text and meta data are formed.</td>
                  </tr>
                  <tr>
                    <td><tt>fields="</tt><em>Field1</em><tt>,</tt><em>Field2</em><tt>,</tt>...<tt>"</tt></td>
                    <td>is a multi-field alternative to the <tt>field</tt> attribute. It  identifies a list of fields in the index to search, instead of a single field. Using a list of fields is an ideal way to perform a "keyword" search, for example searching the title, subject, author, and full text of documents. It should be mentioned that the <tt>fields</tt> attribute is only applicable to <tt>&lt;and&gt;</tt> and <tt>&lt;or&gt;</tt> queries. As with the <tt>field</tt> attribute, any elements nested within the tag are <strong><em>not</em></strong> allowed to specify a field or fields.</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets="</tt><em>SnippetsToOutput</em><tt>"</tt></td>
                    <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute. If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, if the maxSnippets attribute appears in any containing tags, the value set for it in the <tt>&lt;and&gt;</tt> tag must match the value set in the containing tags. Otherwise, an error will be generated. Similarly, any occurrences of the maxSnippets attribute in tags within the <tt>&lt;and&gt;</tt> tag must have the same value as their containing tags. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost="</tt><em>BoostValue</em><tt>"</tt></td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this clause in the query. Boost values higher than 1.0 increase the relevance of a clause, while boost values between 0.0 and 1.0 decrease the relevance of a clause. Boost values less than zero will generate an error. Note that boost values multiply. That is, if tags within an <tt>&lt;and&gt;</tt> tag have boost attributes, their individual boost values will be multiplied by the boost set for the containing <tt>&lt;and&gt;</tt> tag.</td>
                  </tr>
                  <tr>
                    <td><tt>useProxmity="</tt><em>YesOrNo</em><tt>"</tt></td>
                    <td>is an optional attribute that specifies whether the AND query should take the proximity of terms into account. Generally it's best to leave this on (the default) as it results in higher quality results for the user. However, turning it off can increase query processing speed, as the Text Engine will have less work to do to calculate which documents match the query. If not specified, this attribute defaults to Yes, that is, proximity will be taken into account. Note that if proximity processing is turned off, individual text hits within document text and meta-data fields will <em>not</em> be highlighted, and scores for matching documents will be somewhat different.</td>
                  </tr>
                </tbody>
              </table>
              Within the <tt>&lt;and&gt;</tt> tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a>, <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag. If the field is <tt>"text"</tt>, a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type</a> sub-query may optionally appear, restricting this query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>Or Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Or">&lt;or&gt;</a>
              
              This tag defines a search where any one of the sub-terms or clauses must exist in a document for a match to be made. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;or {field       = "FieldName" |
     fields      = "Field1,Field2,..."}
    {slop        = "MaxMatchDistance"}
    {maxSnippets = "SnippetsToOutput"}
    {boost       = "BoostValue"}&gt;
    
    Term | Clause
    Term | Clause
    …
    
    {OptionalSectionTypeQuery}
    
&lt;/or&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>field="</tt><em>FieldName</em><tt>"</tt></td>
                    <td>is an optional attribute that identifies which field in the index to search. Normally, this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that if the field attribute appears in any tags outside it, the field name in the <tt>&lt;or&gt;</tt> tag must match the value set in the outer tags. Otherwise, an error will be generated. However, if the <tt>&lt;or&gt;</tt> tag does not specify a field name, and no tags outside it specify a field name, then the tags directly below the <tt>&lt;or&gt;</tt> tag may have any combination of field names desired. This is how mixed queries of document text and meta data are formed.</td>
                  </tr>
                  <tr>
                    <td><tt>fields="</tt><em>Field1</em><tt>,</tt><em>Field2</em><tt>,</tt>...<tt>"</tt></td>
                    <td>is a multi-field alternative to the <tt>field</tt> attribute. It  identifies a list of fields in the index to search, instead of a single field. Using a list of fields is an ideal way to perform a "keyword" search, for example searching the title, subject, author, and full text of documents. It should be mentioned that the <tt>fields</tt> attribute is only applicable to <tt>&lt;and&gt;</tt> and <tt>&lt;or&gt;</tt> queries. As with the <tt>field</tt> attribute, any elements nested within the tag are <strong><em>not</em></strong> allowed to specify a field or fields.</td>
                  </tr>
                  <tr>
                    <td><tt>slop=</tt>"<em>MaxMatchDistance</em>"</td>
                    <td>is a measure of the "nearness" of the terms or clauses within a given field of a multi-field query. Note that this attribute is <i>required</i> for multi-field <tt>&lt;or&gt;</tt> queries, and <i>not allowed</i> for single-field <tt>&lt;or&gt;</tt> queries. To get an idea of what <tt>slop</tt> does, see the discussion of this attribute for the related <tt>&lt;orNear&gt;</tt> query, following this query.</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets="</tt><em>SnippetsToOutput</em><tt>"</tt></td>
                    <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute. If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, if the maxSnippets attribute appears in any containing tags, the value set for it in the <tt>&lt;or&gt;</tt> tag must match the value set in the containing tags. Otherwise, an error will be generated. Similarly, any occurrences of the maxSnippets attribute in tags within the <tt>&lt;or&gt;</tt> tag must have the same value as their containing tags. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost="</tt><em>BoostValue</em><tt>"</tt></td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this clause in the query. Boost values higher than 1.0 increase the relevance of a clause, while boost values between 0.0 and 1.0 decrease the relevance of a clause. Boost values less than zero will generate an error. Note that boost values multiply. That is, if tags within an <tt>&lt;or&gt;</tt> tag have boost attributes, their individual boost values will be multiplied by the boost set for the containing <tt>&lt;or&gt;</tt> tag.</td>
                  </tr>
                </tbody>
              </table>
              If a single field is specified (using the <tt>field</tt> attribute), documents will match if <em>any</em> search term occurs in that field. Documents with more matching terms will score and rank higher than those with fewer matching terms.
              
              If multiple fields are specified (using the <tt>fields</tt> attribute), documents will match if <em>any</em> search term occurs in <em>any</em> of the listed fields. Documents with more matching terms (in any field) will score and rank higher than those with fewer matching terms. This will internally decompose to a conjoined set of <tt>&lt;orNear&gt;</tt> queries; hence the requirement for the <tt>slop</tt> attribute in this case.
              
              Within the or tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a>, <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag. If the field is "text", a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type</a> sub-query may optionally appear, restricting this phrase query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>OrNear Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_OrNear">&lt;orNear&gt;</a>
              
              This tag defines a search where at least one of the sub-terms or clauses must be in a document. If multiple terms do appear, hits where the terms are close together will score higher than those where the terms are far from each other. Essentially, this provides the functionality of an &lt;or&gt; search, with improved scoring. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;orNear slop         = "MaxMatchDistance"
        {field       = "FieldName"}
        {maxSnippets = "SnippetsToOutput"}
        {boost       = "BoostValue"}&gt;
        
    Term | Clause
    Term | Clause
    …
    
    {OptionalSectionTypeQuery}
        
&lt;/orNear&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>slop=</tt>"MaxMatchDistance"</td>
                    <td>is a measure of the "nearness" of the terms or clauses specified. See the discussion of slop calculation below.</td>
                  </tr>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is an optional attribute that identifies which field in the index to search. Often this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that the field name specified by a <tt>&lt;orNear&gt;</tt> tag must match the field name set by any tags that contain it. Otherwise, an error will be generated. If no parent tags specify a field name, any field name can be used by the <tt>&lt;orNear&gt;</tt> tag. Similarly, any tags within a <tt>&lt;orNear&gt;</tt> tag must either specify the same field name as the orNear clause, or specify no field name at all. Otherwise, an error will be generated. (Note: Allowing nested copies of the field attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost field value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets=</tt>"SnippetsToOutput"</td>
                    <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute.   If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, if the maxSnippets attribute appears in any containing tags, the value set for it in the <tt>&lt;orNear&gt;</tt> tag must match the value set in the containing tags. Otherwise, an error will be generated. Similarly, any occurrences of the maxSnippets attribute in tags within the <tt>&lt;orNear&gt;</tt> tag must have the same value as their containing tags. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost=</tt>"BoostValue"</td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this clause in the query. Boost values higher than 1.0 increase the relevance of a clause, while boost values between 0.0 and 1.0 decrease the relevance of a clause. Boost values less than zero will generate an error. Note that boost values multiply. That is, if tags within an <tt>&lt;orNear&gt;</tt> tag have boost attributes, their individual boost values will be multiplied by the boost set for the containing <tt>&lt;orNear&gt;</tt> tag.</td>
                  </tr>
                </tbody>
              </table>
              Within the OrNear tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a>,  <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag.
              
              A slop value for a potential match is accumulated as follows:
              <ol>
                <li> A potential match is found when all the items specified in the orNear  tag are found in a document. Initially, the accumulated slop for this potential match is set to zero.</li>
                <li> Next the accumulated slop is incremented by one for each word in the potential match that doesn't appear in orNear tag.</li>
                <li> Finally, the accumulated slop is incremented by one each time a word specified in the orNear tag appears out of order in the document. If the final accumulated slop exceeds the value set by the slop  attribute of the orNear tag, the terms are considered to be separate (and thus lower scoring).</li>
              </ol>
              It should also be noted that, when applied to the "text" field, if the value specified for the slop attribute exceeds the maximum proximity for the index being used, the maximum proximity value will be used instead. There is no limit on the slop attribute when applied to meta-data fields.
              If the field is "text", a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type</a> sub-query may optionally appear, restricting this query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>Not Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Not">&lt;not&gt;</a>
              
              This tag defines a search where none of the sub-terms or clauses must exist in a document for a match to be made. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;not {field       = "FieldName"}
     {maxSnippets = "SnippetsToOutput"}
     {boost       = "BoostValue"}&gt;
    
    Term | Clause
    Term | Clause
    …
&lt;/not&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is an optional attribute that identifies which field in the index to search. Normally, this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that if the field attribute appears in any tags outside it, the field name in the <tt>&lt;not&gt;</tt> tag must match the value set in the outer tags. Otherwise, an error will be generated. However, if the <tt>&lt;not&gt;</tt> tag does not specify a field name, and no tags outside it specify a field name, then the tags directly below the <tt>&lt;not&gt;</tt> tag may have any combination of field names desired. This is how mixed queries of document text and meta data are formed.</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets=</tt>"SnippetsToOutput"</td>
                    <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute. If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, if the maxSnippets attribute appears in any containing tags, the value set for it in the <tt>&lt;not&gt;</tt> tag must match the value set in the containing tags. Otherwise, an error will be generated. Similarly, any occurrences of the maxSnippets attribute in tags within the <tt>&lt;not&gt;</tt> tag must have the same value as their containing tags. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost=</tt>"BoostValue"</td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this clause in the query. Boost values higher than 1.0 increase the relevance of a clause, while boost values between 0.0 and 1.0 decrease the relevance of a clause. Boost values less than zero will generate an error. Note that boost values multiply. That is, if tags within an <tt>&lt;not&gt;</tt> tag have boost attributes, their individual boost values will be multiplied by the boost set for the containing <tt>&lt;not&gt;</tt> tag.</td>
                  </tr>
                </tbody>
              </table>
              Within the not tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a>, <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a> tag.
              
              The not tag is usually used to restrict the results of a larger query (such as an <strong>and</strong>, <strong>or</strong>, or <strong>near</strong> query.) To use it this way, embed the not tag within another query tag. However, not can also be used alone at the top level (just inside the &lt;query&gt; element), and the effect is to gather <em>all</em> documents that don't match the &lt;not&gt; specification.
              
              It is important to note that when applied to the "text" field, the not tag in reality operates as a <strong>"not near."</strong> That is, the items to not be found are localized to other terms in the search query. Why? Consider a query for <strong>"bat" not "cave"</strong>. Imagine a document where <strong>"bat man"</strong> appears in Chapter 1. Would you really want to ignore that match if the word "cave" appears in a wholly unrelated passage somewhere in Chapter 12? Probably not. Consequently, search elements specified within a &lt;not&gt; clause are considered relevant if they are within the same chunk as other elements in the query. For more about document chunks sizing, see <strong><a href="http://xtf.cdlib.org/documentation/deployment-guide#textIndexer_Config_File">textIndexer Configuration File</a></strong> section in the <strong><a href="#deployment">XTF Deployment Guide</a></strong>. By contrast, when applied to meta-data fields, the &lt;not&gt; clause operates as a "<strong>not anywhere</strong>", and ignores chunk sizing.
          </li>
          
          <li><u>Near Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Near">&lt;near&gt;</a>
              
              This tag defines a search where all of the sub-terms or clauses must be in a document, <strong>and</strong> within a specified distance of each other for a match to be made. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;near slop         = "MaxMatchDistance"
      {field       = "FieldName"}
      {maxSnippets = "SnippetsToOutput"}
      {boost       = "BoostValue"}&gt;
      
    Term | Clause
    Term | Clause
    …
    
    {OptionalSectionTypeQuery}
      
&lt;/near&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>slop=</tt>"MaxMatchDistance"</td>
                    <td>is a measure of the "nearness" of the terms or clauses specified. See the discussion of slop values below.</td>
                  </tr>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is an optional attribute that identifies which field in the index to search. Often this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that the field name specified by a <tt>&lt;near&gt;</tt> tag must match the field name set by any tags that contain it. Otherwise, an error will be generated. If no parent tags specify a field name, any field name can be used by the <tt>&lt;near&gt;</tt> tag. Similarly, any tags within a <tt>&lt;near&gt;</tt> tag must either specify the same field name as the near clause, or specify no field name at all. Otherwise, an error will be generated. (Note: Allowing nested copies of the field attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost field value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets=</tt>"SnippetsToOutput"</td>
                    <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute.   If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, if the maxSnippets attribute appears in any containing tags, the value set for it in the <tt>&lt;near&gt;</tt> tag must match the value set in the containing tags. Otherwise, an error will be generated. Similarly, any occurrences of the maxSnippets attribute in tags within the <tt>&lt;near&gt;</tt> tag must have the same value as their containing tags. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost=</tt>"BoostValue"</td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this clause in the query. Boost values higher than 1.0 increase the relevance of a clause, while boost values between 0.0 and 1.0 decrease the relevance of a clause. Boost values less than zero will generate an error. Note that boost values multiply. That is, if tags within an <tt>&lt;near&gt;</tt> tag have boost attributes, their individual boost values will be multiplied by the boost set for the containing <tt>&lt;near&gt;</tt> tag.</td>
                  </tr>
                </tbody>
              </table>
              A slop value for a potential match is accumulated as follows:
              <ol>
                <li> A potential match is found when all the items specified in the near  tag are found in a document. Initially, the accumulated slop for this potential match is set to zero.</li>
                <li> Next the accumulated slop is incremented by one for each word in the potential match that doesn't appear in near tag.</li>
                <li> Finally, the accumulated slop is incremented by one each time a word specified in the near tag appears out of order in the document. If the final accumulated slop exceeds the value set by the slop  attribute of the near tag, the potential match is ignored.   Note that setting the slop value for the near tag to zero effectively produces an exact phrase search, and is in fact how the phrase tag is implemented internally.</li>
              </ol>
              Within the near tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a>,  <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag.
              
              It should also be noted that, when applied to the "text" field, if the value specified for the slop attribute exceeds the maximum proximity for the index being used, the maximum proximity value will be used instead. There is no limit on the slop attribute when applied to meta-data fields.
              If the field is "text", a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type</a> sub-query may optionally appear, restricting this query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>Range Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Range">&lt;range&gt;</a>
              
              This tag matches any words that fall within the range specified by the specified first and last term. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;range {inclusive   = "YesOrNo"}
       {numeric     = "YesOrNo"}
       {field       = "FieldName"}
       {maxSnippets = "SnippetsToOutput"}
       {boost       = "BoostValue"}&gt;
      
    &lt;lower&gt;FirstTermToFind&lt;/lower&gt;
    &lt;upper&gt;LastTermToFind&lt;/upper&gt;
    
    {OptionalSectionTypeQuery}
      
&lt;/range&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>inclusive=</tt>"YesOrNo"</td>
                    <td>is an optional attribute that specifies whether the range should include the first and last term when matching. If not specified, this attribute defaults to <strong>yes</strong>.</td>
                  </tr>
                  <tr>
                    <td><tt>numeric=</tt>"YesOrNo"</td>
                    <td>is an optional attribute that specifies whether the data in the field is numeric and in a rigid consistent format. If set to yes, upon the first range query on the field, XTF will read into memory a table of all the data values, converting them to 64-bit integers; subsequent queries can then be processed extremely efficiently. If this attribute is set to no, the query is much more tolerant of variable formatting in the data; XTF will expand the range query into a multi-term OR (just like a wildcard query.) However, for some types of data, wildcard expansion can result in too many terms for the engine to handle. If not specified, this attribute defaults to no.</td>
                  </tr>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is an optional attribute that identifies which field in the index to search. Often this attribute is set to text to indicate that the main text of the document should be searched. It can also be set to the name of a meta field such as author or subject. It should be mentioned that if the field attribute appears in any tags outside it, the field name in the <tt>&lt;range&gt;</tt> tag must match the value set in the outer tags. Otherwise, an error will be generated. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>maxSnippets=</tt>"SnippetsToOutput"</td>
                    <td>is an optional attribute that identifies the number of snippets to pass on to the <strong>Result Formatter</strong> stylesheet for display. A snippet is defined as the matching text found in a document for a particular query, along with some additional text around it for context. The amount of context displayed for each match is defined by the maxContext attribute. If not specified this attribute defaults to 3, meaning snippets for the top three matches for a document are returned. Also, this attribute can be set to -1, meaning all the snippets for a document are returned. As with the field attribute, if the maxSnippets attribute appears in any containing tags, the value set for it in the <tt>&lt;range&gt;</tt> tag must match the value set in the containing tags. Otherwise, an error will be generated. (Note: Allowing nested copies of the maxSnippets attribute doesn't serve a purpose other than to make it easier to write <strong>docReqParser.xsl</strong> stylesheets in a uniform way. Effectively, the outermost maxSnippets value is always used.)</td>
                  </tr>
                  <tr>
                    <td><tt>boost=</tt>"BoostValue"</td>
                    <td>is an optional attribute that specifies a relevance boost multiplier for this clause in the query. Boost values higher than 1.0 increase the relevance of a clause, while boost values between 0.0 and 1.0 decrease the relevance of a clause. Boost values less than zero will generate an error.</td>
                  </tr>
                  <tr>
                    <td>FirstTermToFind</td>
                    <td>is the first term in the range to find. Usually, this is a starting number, date, or year.</td>
                  </tr>
                  <tr>
                    <td>LastTermToFind</td>
                    <td>is the last term in the range to find. Usually, this is an ending number, date, or year.</td>
                  </tr>
                </tbody>
              </table>
              This tag returns a match for any word that lexicographically falls in the range specified by the upper and lower tags. This tag is primarily used to search for a range of revision numbers, dates, or years.
              
              If the field is "text", a <a href="#tagRef_crossQuery_QueryParser_Output_SectionType">Section Type</a> sub-query may optionally appear, restricting this query to particular sections of a document based on section types added by the <strong>Pre-Filter</strong> stylesheet at index time.
          </li>
          
          <li><u>Section Type Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_SectionType">&lt;sectionType&gt;</a>
              
              This tag modifies other queries, causing them to apply to only certain portions of the full text of a document. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;sectionType&gt;
                
    Term | Clause
    
&lt;/sectionType&gt;</pre>
              This tag may only be used within another query, and has the effect of limiting that query to search only those parts of the full document text whose sectionType attributes match the specified term or clause. The sectionType tag is only allowed within queries on the "text" field. XTF evaluates the specified term or clause against the section type attributes recorded at index time by the <strong>Pre-Filter</strong> stylesheet using the <a href="#tagRef_textIndexer_PreFilter_SectType">xtf:sectionType</a> attribute.
              
              For example, if one wanted the option to only search the chapter headings of all books in a repository, then the pre-filter would be modified to mark all the headings with xtf:sectionType="heading", and then a sectionType tag would be added within the main text query, containing term tag on the word "heading".
              
              Within the sectionType tag, Term is a <a href="#tagRef_crossQuery_QueryParser_Output_Term">term</a> tag, and Clause is a <a href="#tagRef_crossQuery_QueryParser_Output_Phrase">phrase</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Exact">exact</a>, <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a>, <a href="#tagRef_crossQuery_QueryParser_Output_OrNear">orNear</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a>, <a href="#tagRef_crossQuery_QueryParser_Output_Range">range</a>, <a href="#tagRef_crossQuery_QueryParser_Output_ResultData">resultData</a>, or <a href="#tagRef_crossQuery_QueryParser_Output_Not">not</a> tag.
          </li>
          
          <li><u>Facet Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Facet">&lt;facet&gt;</a>
              
              This tag specifies a facet for which to count hits and form groups, and optionally to gather document hits. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;facet field               = "FieldName"
       {select             = "GroupsToSelect"}
       {sortGroupsBy       = "SortKind"}
       {sortDocsBy         = "ListOfMetaFields|score|totalHits"}
       {includeEmptyGroups = "YesOrNo"} /&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is a required attribute that identifies which meta-data field in the index for which to count and build groups. (Note: Meta tags to be used for faceted queries should also have an xtf:tokenize="no" attribute set, or sorting will produce unpredictable results.)</td>
                  </tr>
                  <tr>
                    <td><tt>select=</tt>"GroupsToSelect"</td>
                    <td>is an optional attribute specifying a subset of groups to select and return in the query result. For maximum flexibility, this specification is made using a special language that resembles XPath to some extent. It allows selecting groups by name or position in the list, and supports various operations on hierarchical meta-data. See examples below. If this attribute is not specified, it defaults to: <tt>*</tt></td>
                  </tr>
                  <tr>
                    <td><tt>sortGroupsBy=</tt>"TotalDocsOrValue"</td>
                    <td>is an optional attribute telling XTF the order in which to sort groups.
                      <ul>
                        <li>If set to "totalDocs" (or not set), groups will be sorted in decreasing order of the total number of documents per group.</li>
                        <li>If set to "value", groups will be sorted in increasing order by the value (i.e. name) of the facet group. "reverseValue" is also supported.</li>
                        <li>If set to "maxDocScore", groups will be sorted in decreasing order by their relevance score (relevance judged in relation to the main query.)</li>
                      </ul>
                    </td>
                  </tr>
                  <tr>
                    <td><tt>sortDocsBy=</tt><br/>"ListOfMetaFields|score|totalHits"</td>
                    <td>is an optional attribute specifying a list of meta fields by which to sort the results. The list should consist of a quoted string containing one or more meta-field names, separated by commas. If multiple meta-fields are specified, the results are sorted first by the leftmost meta-field, then sub-sorted by subsequent fields to produce the final output. Optionally, each meta-field name can be preceded by a plus sign (<strong>+</strong>) or a minus sign (<strong>-</strong>) to indicate whether the results for that field should be sorted in ascending or descending order. If no plus or minus sign is specified for a meta-field, then the results are sorted in ascending order by default.<br/> 
                      An additional option is available: setting this attribute to "totalHits" will order the results by descending number of hits within each document. That is, a document with more hits will appear before one with fewer hits, regardless of the <em>quality</em> of those hits.<br/>
                      If this attribute is not specified, documents are by default sorted in order of decreasing score (so the most "relevant" documents are first.) This default behavior can also be explicitly set by providing a value of "score" (or synonym “relevance”). <br/>
                      (Note: Meta tags to be used for sorting should also have an xtf:tokenize="no" attribute set, or sorting will produce unpredictable results.)</td>
                  </tr>
                  <tr>
                    <td><tt>includeEmptyGroups=</tt>"YesOrNo"</td>
                    <td>is an optional attribute that specifies whether to include empty groups in the results. If set to "yes", empty groups will be included. If set to "no" they will be excluded. If this attribute is not specified, it defaults to "no."</td>
                  </tr>
                </tbody>
              </table>
              The <tt>&lt;facet&gt;</tt> tag enables counting and grouping for a single meta-data field. First, XTF scans the index and forms a table of all the possible values of that field. Then the query is performed as normal, as each document hit is encountered, XTF looks up that document's value in the table and increments the count for it. If enabled in the selection specification, a list of the document hits for each value is also accumulated.
              
              After the counting is completed, XTF sorts them, removes empty groups if enabled, and then applies the group selection specification (from the select attribute) to decide which groups to send to the <strong>Result Formatter</strong> stylesheet. For more information on the selection process, see the <a href="http://xtf.cdlib.org/documentation/programming-guide#programming_Faceted_Browsing_GroupSelection">Group Selection</a> section of the <strong>XTF Programmer's Guide</strong>. The final selected groups will appear within a <a href="#tagRef_crossQuery_ResultFormatter_Facet">Facet Result</a> tag in the results.
              Note that only one facet query is allowed per meta-data field. Trying to specify more than one will result in an error message.
              
              Some examples of the <tt>select</tt> attribute:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">  *[1-5]
  Politics#all
  **[topChoices]
  US::Berkeley#all|US::*
  History#all|**[selected][page(size=5)]</pre>
              For more information, refer to the <a href="http://xtf.cdlib.org/documentation/programming-guide#programming_Faceted_Browsing_GroupSelection">Group Selection</a> section of the <strong>XTF Programmer's Guide</strong>.
          </li>
          
          <li><u>Spellcheck Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_Spellcheck">&lt;spellcheck&gt;</a>
              
              This tag specifies that the Text Engine should evaluate whether terms of the query were likely misspelled, and to suggest likely correction(s) for each term. This tag should appear directly within a <a href="#tagRef_crossQuery_QueryParser_Output_Query">Query Tag</a>.
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;spellcheck {fields          = "FieldNames" }
            {docScoreCutoff  = "MaxDocScore"}
            {totalDocsCutoff = "MaxDocCount"}/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>fields=</tt>"FieldNames"</td>
                    <td>is an optional attribute that restricts spelling correction to the specified set of fields. The field names can be separated by commas, semicolons, pipe symbols (|), or spaces. If not specified, or if set to the special value #all, then all tokenized fields in the index will be checked for spelling (including the special field text which contains all words not marked as meta-data.)   Specifying a subset of fields can speed up query processing if the <strong>Query Parser</strong> stylesheet introduces extra fields that the user didn't explicitly type, and thus needn't be checked for spelling.</td>
                  </tr>
                  <tr>
                    <td><tt>docScoreCutoff=</tt>"MaxDocScore"</td>
                    <td>is an optional attribute that controls whether XTF performs spelling correction. If any document resulting from the query scores higher than this number, no correction will be performed. If not specified, this attribute defaults to 0.0, which disables the score cutoff.</td>
                  </tr>
                  <tr>
                    <td><tt>totalDocsCutoff=</tt>"MaxDocCount"</td>
                    <td>is an optional attribute that controls whether XTF performs spelling correction. If the number of documents resulting from the query exceeds this number, spelling correction will not be performed. If set to zero, the document count cutoff is disabled (correction will always be considered.) If not specified, this attribute defaults to 10, meaning that if less than 10 documents are found by a query, spelling correction is applied.</td>
                  </tr>
                </tbody>
              </table>
              If spelling corrections are found, the <strong>Result Formatter</strong> stylesheet will receive a <a href="#tagRef_crossQuery_ResultFormatter_Spelling">Spelling Result</a> tag.
          </li>
          
          <li><u>Result Data Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_ResultData">&lt;resultData&gt;</a>
              
              This tag allows the <strong>Query Parser</strong> stylesheet to pass arbitrary data on to the <strong>Result Formatter</strong> stylesheet. XTF will not attempt to interpret the contents of the tag, but simply passes the tag and its contents through unchanged into the <a href="#tagRef_crossQuery_ResultFormatter_CrossQRes">Query Result Tag</a>. This tag may appear anywhere within a query.
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;resultData&gt;
    
    YourDataHere
    
&lt;/resultData&gt;</pre>
    XTF will pass the tag and its contents unchanged to the result formatter.
          </li>
          
          <li><u>More Like Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_MoreLike">&lt;moreLike&gt;</a>
              
              This tag specifies that XTF should locate documents "similar" to a given document, where many of the similarity parameters can be controlled. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;moreLike  fields        = "FieldList"
          {boosts        = "BoostFactorList"}
          {minWordLen    = "MinWordLength"}
          {maxWordLen    = "MaxWordLength"}
          {minDocFreq    = "MinDocFrequency"}
          {maxDocFreq    = "MaxDocFrequency"}
          {minTermFreq   = "MinTermFrequency"}
          {termBoost     = "ShouldBoostTerms"}
          {maxQueryTerms = "MaxQueryTerms"}&gt;
            
    DocumentQuery
            
&lt;/moreLike&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>fields="</tt><em>FieldList</em><tt>"</tt></td>
                    <td>is a required attribute naming all of the fields that XTF should search for "interesting" terms. The field names may be separated by spaces, commas, semicolons, or pipe symbols "|". For best performance, this list should be kept relatively small, and concentrate on fields of most interest to users, such as title, author, subject, etc. Note that XTF currently does <span class="underline">not</span> support using the special field name text to search the full document text for interesting terms, and behavior is undefined if you specify this as a field name.</td>
                  </tr>
                  <tr>
                    <td><tt>boosts="</tt><em>BoostFactorList</em><tt>"</tt></td>
                    <td>is an optional attribute specified exactly one boost factor for each field listed in the fields attribute. Each boost factor should be a non-negative decimal number, and is multiplied into the scoring for all terms from the given field. For example, a boost factor of 0.5 will reduce the score for terms by half, while a factor of 2.0 will double the score. In general, the boost factor is very useful in adjusting the weight that various fields have on selecting similar documents. For instance, if one decided that the title should be twice as important as author and subject, the fields attribute might be "title,author,subject" and the boosts attribute would be "2.0,1.0,1.0". If not specified, the boost factor for all fields in the fields list is set to 1.0.</td>
                  </tr>
                  <tr>
                    <td><tt>minWordLen="</tt><em>MinWordLength</em><tt>"</tt></td>
                    <td>is an optional attribute that limits the length of terms from the source fields that will be considered for similarity matching. Terms shorter than the specified number of characters will be disregarded. This can speed up processing and improve results by getting rid of useless words. If not specified, this attribute defaults to 4.</td>
                  </tr>
                  <tr>
                    <td><tt>maxWordLen="</tt><em>MaxWordLength</em><tt>"</tt></td>
                    <td>is an optional attribute that limits the length of terms from the source fields will be considered for similarity matching. Terms longer than the specified number of characters will be disregarded. This can speed up processing and improve results by getting rid of useless words. If not specified, this attribute defaults to 12.</td>
                  </tr>
                  <tr>
                    <td><tt>minDocFreq="</tt><em>MinDocFrequency</em><tt>"</tt></td>
                    <td>is an optional attribute that helps select which terms from source fields will be considered for similarity matching. In particular, terms that appear in fewer than the specified number of documents will be discarded. This can speed processing and improve results by discarding highly unusual terms. If not specified, this attribute defaults to 2.</td>
                  </tr>
                  <tr>
                    <td><tt>maxDocFreq="</tt><em>MaxDocFrequency</em><tt>"</tt></td>
                    <td>is an optional attribute that helps select which terms from source fields will be considered for similarity matching. In particular, terms that appear in more than the specified number of documents will be discarded. This can speed processing and improve results by discarding very common terms. If not specified, this attribute defaults to -1, meaning that there is no limit at all.</td>
                  </tr>
                  <tr>
                    <td><tt>minTermFreq="</tt><em>MinTermFrequency</em><tt>"</tt></td>
                    <td>is an optional attribute that helps select which terms from source fields will be considered for similarity matching. In particular, if the term occurs in the original field less than the specified number of times, it will be discarded. This can help choose more relevant terms by concentrating on those that are repeated in the field. If not specified, this attribute defaults to 1.</td>
                  </tr>
                  <tr>
                    <td><tt>termBoost="</tt><em>ShouldBoostTerms</em><tt>"</tt></td>
                    <td>is an optional attribute controls whether the similarity engine should calculate and attach a boost factor to each term. This factor will be equal to the score that was calculated for that term, and serves to make more important terms select documents more specifically. In general, it's best to leave this at the default value, which is true.</td>
                  </tr>
                  <tr>
                    <td><tt>maxQueryTerms="</tt><em>MaxQueryTerms</em><tt>"</tt></td>
                    <td>is an optional attribute that controls how many "interesting" terms are selected from the original document's fields. Generally, this should be chosen to balance speed (more terms take longer to process) vs. quality (more terms can result in higher quality results, up to a point.) If not specified, this attribute defaults to 10.</td>
                  </tr>
                </tbody>
              </table>
              Within the <tt>moreLike</tt> tag, <em>DocumentQuery</em> is a normal XTF query that results in a single document. That document's fields will be scanned, and each term will be scored for "interestingness" subject to the attributes above. Those terms that rank highest will be combined into a new <tt>&lt;orNear&gt;</tt> query, and the results will be documents that are similar to the original document selected by DocumentQuery.
          </li>
          
          <li><u>All Docs Tag</u>: <a name="tagRef_crossQuery_QueryParser_Output_allDocs">&lt;allDocs&gt;</a>
              
              This special query tag matches all of the documents in the index. Doing this can be useful in conjunction with faceted browsing, in order to explore the entire collection rather than a subset of it. This should appear within a &lt;query&gt; element, and has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;allDocs/&gt;</pre>
            
          </li>
        </ul>
      </li>
    </ul>
    
    <h3>Search Result Formatter</h3>
    <ul>
      <li><a name="searchResultInputTag">Input Tags</a>
        
        The following tags make up the XML input for the Search Result Formatter stylesheet. They constitute a simple XML representation of the matching text found for the most recent query. The Search Result Formatter stylesheet uses these input tags to generate the HTML for the actual search result web-page viewed by the user. The root tag is &lt;crossQueryResult&gt;.
        <blockquote><a href="#tagRef_crossQuery_ResultFormatter_CrossQRes">&lt;crossQueryResult&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_DocHit">&lt;docHit&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_Meta">&lt;meta&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_Snippet">&lt;snippet&gt;</a>
          
          <a href="#tagRef_crossQuery_ResultFormatter_Hit">&lt;hit&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_Term">&lt;term&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_Explanation">&lt;explanation&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_Facet">&lt;facet&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_Group">&lt;group&gt;</a>
          
          <a href="#tagRef_crossQuery_ResultFormatter_Spelling">&lt;spelling&gt;</a>
          <a href="#tagRef_crossQuery_ResultFormatter_SpellingSuggestion">&lt;suggestion&gt;</a></blockquote>
        
        <ul>
          <li><u>Query Result Tag</u> <a name="tagRef_crossQuery_ResultFormatter_CrossQRes">&lt;crossQueryResult&gt;</a>
              
              This tag is the outermost container tag for the results produced by the crossQuery servlet. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;crossQueryResult queryTime = "TimeInSeconds"
                  totalDocs = "NumberOfDocs"
                  startDoc  = "FirstDocNumber"
                  endDoc    = "LastDocNumber"&gt;
                 
    Parameters
    Query
    
    Spelling      &lt;!-- if spelling corrections requested and applicable --&gt;
    
    DocumentHit
    DocumentHit
    …
    
    FacetResult   &lt;!-- if facets were queried --&gt;
    
    FacetResult
    
&lt;/crossQueryResult&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>queryTime=</tt>"TimeInSeconds"</td>
                    <td>is the amount of time, in seconds, that the servlet spent parsing the query, processing it, and gathering the results.</td>
                  </tr>
                  <tr>
                    <td><tt>totalDocs=</tt>"NumberOfDocs"</td>
                    <td>is the number of documents that had matches for the specified query.</td>
                  </tr>
                  <tr>
                    <td><tt>startDoc=</tt>"FirstDocNumber"</td>
                    <td>is the sequential document number for the highest ranking document returned by the current Query. Note that this may not be the overall highest ranking document if a paged query was specified. See the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag for more details about performing paged queries.</td>
                  </tr>
                  <tr>
                    <td><tt>endDoc=</tt>"LastDocNumber"</td>
                    <td>is the sequential document number for the lowest ranking document match returned by the current query. Note that this may not be the overall lowest ranking document if a paged query was specified. See the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag for more details about performing paged queries.</td>
                  </tr>
                </tbody>
              </table>
              and
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>Parameters</tt></td>
                    <td>is the same <tt>&lt;parameters&gt;</tt> block that was sent to the Query Parser stylesheet</td>
                  </tr>
                  <tr>
                    <td><tt>Query</tt></td>
                    <td>is the query block that was output by the Query Parser stylesheet, included for reference. This <tt>&lt;query&gt;</tt> block and the <tt>&lt;parameters&gt;</tt> block may be useful to the <strong>Search Result Formatter</strong> stylesheet in formulating its output.</td>
                  </tr>
                  <tr>
                    <td><tt><a href="#tagRef_crossQuery_ResultFormatter_Spelling">Spelling</a></tt></td>
                    <td>is a tag that will appear only if spell checking was <a href="#tagRef_crossQuery_QueryParser_Output_Spellcheck">enabled</a> in the query, <em>and</em> a spelling correction dictionary was created at index time (i.e. enabled in textIndexer.conf), <em>and</em> the engine detected likely misspelled words and suitable suggested replacements. See the <a href="#tagRef_crossQuery_ResultFormatter_Spelling">Spelling Correction Result Tag</a> tag for more information.</td>
                  </tr>
                  <tr>
                    <td><tt><a href="#tagRef_crossQuery_ResultFormatter_DocHit">DocumentHit</a></tt></td>
                    <td>is one or more tags, one per document in which search hits were found. These tags contain specific hits for each document. See the <a href="#tagRef_crossQuery_ResultFormatter_DocHit">Document Hit Tag</a>
                    </td>
                  </tr>
                  <tr>
                    <td><tt><a href="#tagRef_crossQuery_ResultFormatter_Facet">FacetResult</a></tt></td>
                    <td>is a tag that will be included only if a facet query was performed. These tags will contain grouped counts of the matching documents. See the <a href="#tagRef_crossQuery_ResultFormatter_Facet">Facet Result Tag</a> for more information.</td>
                  </tr>
                </tbody>
              </table>
          </li>
          
          <li><u>Document Hit Tag</u> <a name="tagRef_crossQuery_ResultFormatter_DocHit">&lt;docHit&gt;</a>
              
              This tag identifies a document containing one or more matches for the current query. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;docHit rank  = "DocRelevanceRank"
        path  = "DocumentLocation"
        score = "DocRelevanceScore"&gt;
        
    DocumentMetaData
    
    Snippet
    Snippet
    …
    
    {ScoreExplanation}
        
&lt;/docHit&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>rank=</tt>"DocRelevanceRank"</td>
                    <td>is the ordinal ranking of this matching document, with 1 being the most relevant document for a query. Note that this is an absolute ranking for the document with respect to the entire query, and not a page relative ranking. For more information about paged queries, see the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag.</td>
                  </tr>
                  <tr>
                    <td><tt>path=</tt>"DocumentLocation"</td>
                    <td>is the file path and name for the matching document. This path is relative to the base XTF directory (i.e., XTF_HOME.)</td>
                  </tr>
                  <tr>
                    <td><tt>score=</tt>"DocRelevanceScore"</td>
                    <td>is the document relevance score ranging from 0% to 100%. The document with the highest overall relevance will receive a score of 100%, and less relevant documents will receive lower scores. Note that this score is an overall relevance score and is not affected by paging. For information about paged queries, see the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag.</td>
                  </tr>
                  <tr>
                    <td><tt><a href="#tagRef_crossQuery_ResultFormatter_Meta">Document MetaData</a></tt></td>
                    <td>is a tag which contains the meta-data for the matching document. See the <a href="#tagRef_crossQuery_ResultFormatter_Meta">Document Meta-Data Tag</a> for more information.</td>
                  </tr>
                  <tr>
                    <td><tt><a href="#tagRef_crossQuery_ResultFormatter_Snippet">Snippet</a></tt></td>
                    <td>are tag(s) that contain the text of individual hits within the document, along with surrounding context, as requested in the query. See the <a href="#tagRef_crossQuery_ResultFormatter_Snippet">Snippet Tag</a> for more information.</td>
                  </tr>
                  <tr>
                    <td><tt><a href="#tagRef_crossQuery_ResultFormatter_Explanation"> Score Explanation</a></tt></td>
                    <td>are tags only present if score explanation was requested in the query. These tags detail how the textEngine calculated the score for this document. See the <a href="#tagRef_crossQuery_ResultFormatter_Explanation">Score Explanation Tag</a> for more information.</td>
                  </tr>
                </tbody>
              </table>
          </li>
          
          <li><u>Document Meta-Data Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Meta">&lt;meta&gt;</a>
              
              This tag identifies a block of meta-data for a matching document. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;meta&gt;
    …
&lt;/meta&gt;</pre>
              The actual tags within the meta-data block will depend on the implementation of the <strong><a href="http://xtf.cdlib.org/documentation/programming-guide/#text_pre">Pre-Filter</a></strong> used by the textIndexer. However, any matches found in the meta-data will be marked with <a href="#tagRef_crossQuery_ResultFormatter_Snippet">Snippet</a> or <a href="#tagRef_crossQuery_ResultFormatter_Hit">Hit</a> tags, depending on what the query specified (snippets by default.).
              
              The document meta-data tag is always included in the query results, regardless of whether there are any matches in it or not. This guarantees that the result formatter has access to the title of the document and other document related information in addition to the match results.
          </li>
          
          <li><u>Snippet Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Snippet">&lt;snippet&gt;</a>
              
              This tag contains a snippet of text associated with a match found in a document. The snippet consists of the text matched along with some context text around it. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;snippet rank="MatchRelevanceRank" score="MatchRelevanceScore"&gt;
    
    Hit Text (and context text, if any)
    
&lt;/snippet&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>rank=</tt>"MatchRelevanceRank"</td>
                    <td>is the ordinal ranking of this match in the current document, with 1 being the most relevant match in the document. Note that this is an absolute ranking for the match with respect to the entire document, and not a page relative ranking. For more information about paged queries, see the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag.</td>
                  </tr>
                  <tr>
                    <td><tt>score=</tt>"MatchRelevanceScore"</td>
                    <td>is the relevance score for this match ranging from 0% to 100%. The snippet with the highest overall relevance will receive a score of 100%, and less relevant snippets will receive lower scores. Note that this score is an overall relevance score and is not affected by paging. For information about paged queries, see the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag.</td>
                  </tr>
                </tbody>
              </table>
              The amount of context text displayed in a snippet is determined by the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag in the original query. If the context length specified is less than the matched text, then only the matched text will be displayed.
              
              Within the snippet itself, each matching word from the query will be marked with a single  <a href="#tagRef_crossQuery_ResultFormatter_Term">term</a> tag, and the matching text around which the context text is centered on will also be marked with a single  <a href="#tagRef_crossQuery_ResultFormatter_Hit">hit</a> tag.
          </li>
          
          <li><u>Hit Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Hit">&lt;hit&gt;</a>
              
              This tag identifies actual matched text within the context text of a <a href="#tagRef_crossQuery_ResultFormatter_Snippet">snippet</a> tag. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;hit&gt;    
    …
&lt;/hit&gt;</pre>
              A hit may contain one or more matched words, which are separately marked with term tags.
              
              If the original query used a <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a> or <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a> clause, the hit tag will mark the entire range of text between the first and last word found for the clause. For example, for a "man" near "war" query, the result would look like this:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;snippet rank="3" score="86"&gt;
    
    that &lt;hit&gt;&lt;term&gt;man&lt;/term&gt; had never actually been 
    to &lt;term&gt;war&lt;/term&gt;&lt;/hit&gt;, but he spoke as if he had
    
&lt;/snippet&gt;</pre>
              For an <a href="#tagRef_crossQuery_QueryParser_Output_Or">OR</a> query, if multiple matched words exist in the snippet, all the matched words will be marked with <a href="#tagRef_crossQuery_ResultFormatter_Term">Term</a> tags, but only the word that this snippet is centered around will be marked with a hit tag.
          </li>
          
          <li><u>Term Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Term">&lt;term&gt;</a>
              
              This tag identifies a word in a document that matches one of the terms in the query. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;term&gt;
    MatchedWord
&lt;/term&gt;</pre>
              A term tag may or may not be inside a <a href="#tagRef_crossQuery_ResultFormatter_Hit">hit</a> tag, depending on whether the occurrence of the matched word is within the primary match for a snippet, or simply another occurrence within the context text.
          </li>
          
          <li><u>Explanation Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Explanation">&lt;explanation&gt;</a>
              
              This optional tag contains an explanation of how the score used to rank a document hit was calculated. This tag has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;explanation value="Score" description="Description"&gt;

    &lt;explanation...&gt;
    
    &lt;explanation...&gt;
    ...
    
&lt;/explanation&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td>Score</td>
                    <td>is a floating-point number calculated by XTF</td>
                  </tr>
                  <tr>
                    <td>Description</td>
                    <td>is a brief, technical description of how this score value was calculated.</td>
                  </tr>
                </tbody>
              </table>
              To further describe the score, there may be one or more nested &lt;explanation&gt; elements which break down the score's components, and they may have their own nested explanations in turn.
              
              Score explanations are enabled by setting the explainScores attribute of the <a href="#tagRef_crossQuery_QueryParser_Output_Query">Query Tag</a> produced by the <strong>Query Parser</strong> stylesheet. In the default XTF stylesheets, one can simply add &amp;explainScores=1 to the query URL.
          </li>
          
          <li><u>Facet Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Facet">&lt;facet&gt;</a>
              
              This tag identifies and contains the results for counting/grouping on one facet (or meta-data field). One copy of this tag will be sent into the <strong>Result Formatter</strong> for each <a href="#tagRef_crossQuery_QueryParser_Output_Facet">Facet Query Tag</a> specified in the query. It will appear within a <a href="#tagRef_crossQuery_ResultFormatter_CrossQRes">Query Result Tag</a> container. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;facet field       = "FieldName"
       totalGroups = "NumberOfGroups"
       totalDocs   = "NumberOfDocs"&gt;
      
    GroupResult
    GroupResult
    …
      
&lt;/facet&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>field=</tt>"FieldName"</td>
                    <td>is the name of the meta-data field for which faceted data is being reported.</td>
                  </tr>
                  <tr>
                    <td><tt>totalGroups=</tt>"NumberOfGroups"</td>
                    <td>is the number of groups groups this facet contains (which may be more than are selected and returned as GroupResults.) In the case of a hierarchical facet, this is actually a count of the top-level groups only.</td>
                  </tr>
                  <tr>
                    <td><tt>totalDocs=</tt>"NumberOfDocs"</td>
                    <td>is the number of documents that had matches for the specified query <em>and</em> had a value for this facet.</td>
                  </tr>
                </tbody>
              </table>
              If any groups matched the group selection in the Facet Query Tag, then one or more <a href="#tagRef_crossQuery_ResultFormatter_Group">Group Result Tags</a> will appear as children of the Facet Result Tag.
          </li>
          
          <li><u>Group Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Group">&lt;group&gt;</a>
              
              <a class="missing wiki">#crossQuery_ResultFormatter_Group?</a>This tag identifies and contains the results for the count (and possibly document hits) for a single group within a facet. One copy of this tag will be sent into the <strong>Result Formatter</strong> for group selected by the <a href="#tagRef_crossQuery_QueryParser_Output_Facet">Facet Query Tag</a> specified in the query. The Group Result Tag will appear within a <a href="#tagRef_crossQuery_ResultFormatter_Facet">Facet Result Tag</a> container, or in the case of a hierarchical facet, may appear inside another Group Result Tag. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;group value          = "GroupValue"
       rank           = "GroupSortedRank"
       totalSubGroups = "NumOfSubGroups"
       totalDocs      = "NumberOfDocs"
       startDoc       = "FirstDocNumber"
       endDoc         = "EndDocNumber"&gt;
      
    GroupResult   &lt;!-- if facet is hierarchical --&gt;
    GroupResult
    …
    
    DocumentHit   &lt;!-- if document hits were requested --&gt;
    DocumentHit
    …
      
&lt;/group&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>value=</tt>"GroupValue"</td>
                    <td>is the specific facet value of the group being reported. One might also think of this as the "name" of the group.</td>
                  </tr>
                  <tr>
                    <td><tt>rank=</tt>"GroupSortedRank"</td>
                    <td>is the ordinal ranking of this group within the set of groups at this level, with 1 being the first in sort order. Note that this is an absolute ranking for the group with respect to the entire set, and not a page relative ranking. For more information about paging groups, see the <a href="http://xtf.cdlib.org/documentation/programming-guide#programming_Faceted_Browsing_GroupSelection">Group Selection</a> section of the <strong>XTF Programmer's Guide</strong>.</td>
                  </tr>
                  <tr>
                    <td><tt>totalSubGroups=</tt>"NumOfSubGroups"</td>
                    <td>is, for a hierarchical facet, the number of sub-groups this group contains, which may be more than were actually selected and returned. For a non-hierarchical facet, this will always be zero.</td>
                  </tr>
                  <tr>
                    <td><tt>totalDocs=</tt>"NumberOfDocs"</td>
                    <td>is the number of documents that had matches for the specified main query <strong><em>and</em></strong> had GroupValue in the facet field.</td>
                  </tr>
                  <tr>
                    <td><tt>startDoc=</tt>"FirstDocNumber"</td>
                    <td>is the sequential document number for the highest ranking document match reported for the current group. Note that this may not be the overall highest ranking document if a paged query was specified. See the <a href="http://xtf.cdlib.org/documentation/programming-guide#programming_Faceted_Browsing_GroupSelection">Group Selection</a> section of the <strong>XTF Programmer's Guide</strong> for more details about paging documents.</td>
                  </tr>
                  <tr>
                    <td><tt>endDoc=</tt>"LastDocNumber"</td>
                    <td>is the sequential document number for the lowest ranking document match reported for the current group. Note that this may not be the overall lowest ranking document if a paged query was specified. See the <a href="http://xtf.cdlib.org/documentation/programming-guide#programming_Faceted_Browsing_GroupSelection">Group Selection</a> section of the <strong>XTF Programmer's Guide</strong> for more details about paging documents.</td>
                  </tr>
                </tbody>
              </table>
              If any groups matched the group selection in the Facet Query Tag, then one or more Group Result Tags will appear as children of the Facet Result Tag. If the facet is also hierarchical, Group Result Tags may contain nested Group Result Tags for sub-groups. If any document hits were selected, then one or more <a href="#tagRef_crossQuery_ResultFormatter_DocHit">Document Hit Tags</a> will also be included.
          </li>
          
          <li><u>Spelling Tag</u> <a name="tagRef_crossQuery_ResultFormatter_Spelling">&lt;spelling&gt;</a>
              
              This tag contains the suggestions resulting from spelling correction performed on a user query. It will only appear directly within a <a href="#tagRef_crossQuery_ResultFormatter_CrossQRes">Query Result</a> tag.
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;spelling&gt;
    
    SpellingSuggestion
    SpellingSuggestion
    …
    
&lt;/spelling&gt;</pre>
              Within the Spelling Tag, one ore more <a href="#tagRef_crossQuery_ResultFormatter_SpellingSuggestion">Spelling Suggestion</a> tags will appear, one for each potentially misspelled term in the original query submitted to the engine.
              
              Note that this tag will only appear if spell checking was <a href="#tagRef_crossQuery_QueryParser_Output_Spellcheck">enabled</a> in the query, <em>and</em> a spelling correction dictionary was created at index time (i.e. enabled in textIndexer.conf), <em>and</em> the engine detected likely misspelled words and suitable suggested replacements.
          </li>
          
          <li><u>Spelling Suggestion Tag</u> <a name="tagRef_crossQuery_ResultFormatter_SpellingSuggestion">&lt;suggestion&gt;</a>
              
              This tag contains a spelling suggestion for a single term from the original query submitted to the <strong>Text Engine</strong>. It will appear directly within a <a href="#tagRef_crossQuery_ResultFormatter_Spelling">Spelling Correction Result</a> tag.
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;suggestion origTerm      = "OriginalWord"
            suggestedTerm = "ReplacementWord"/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>origTerm=</tt>"OriginalWord"</td>
                    <td>is the (potentially) misspelled term found in the original query.</td>
                  </tr>
                  <tr>
                    <td><tt>suggestedTerm=</tt>"ReplacementWord"</td>
                    <td>is the best correction that the spelling engine could find for the original term. This may be two words if the original word should be split (e.g. "harrypotter" -&gt; "harry potter"). This may be an empty string, indicating that the original word should be removed from the query (e.g. "usa" "bility" -&gt; "usability" "empty"</td>
                  </tr>
                </tbody>
              </table>
          </li>
        </ul>
      </li>
    </ul>
    
    <h3>Error Generator</h3>
    
    The purpose of the <strong>Error Generator</strong> stylesheet is to generate a web-page that displays user friendly messages when crossQuery errors occur. Since this stylesheet works the same way in both dynaXML and crossQuery, it is documented in the common <a href="#ErrorGenerator">Error Generator Stylesheets</a> section.
    
    <!--Dynaxml tags -->
    <h2 style="border-bottom: medium double black;"><a name="dynamXML">dynamXML</a></h2>
    <a href="#top"><em>return to top</em></a>
    
    <h3><a name="DocReqParser">Document Request Parser</a></h3>
    <ul>
      <li><a name="tagRef_dynaXML_DocReqParser_Input">Document Request Parser Input Tags and Parameters</a>
        
        The XML input fragment passed to the <strong>Document Request Parser</strong> stylesheet forms a simple XML representation of the document request URL supplied to the dynaXML servlet from either a document catalog web-page or a crossQuery search result web-page. The XML input and XSL parameters are the same as those for the crossQuery <strong>Query Parser</strong>, and are documented in the <a href="#http://xtf.cdlib.org/documentation/tag-reference/#routerParserInputTagParameters">Common Parser Input Tags</a> and <a href="#http://xtf.cdlib.org/documentation/tag-reference/#routerParserInputTagParameters">Common Stylesheet Parameters</a> pages.
      </li>
      
      <li><a name="tagRef_dynaXML_DocReqParser_Output">Output Tags</a>
        
        The following tags form the output from a dynaXML Document Request Parser stylesheet. The parser is required to output a document request in the form of at least a &lt;style&gt; tag and an &lt;auth&gt; tag, and optionally other tags as outlined below. This XML request is then passed to the dynaXML servlet's document retrieval engine for processing.
        <blockquote><a href="#tagRef_dynaXML_ReqParser_Output_Style">&lt;style&gt;</a>
          
          <a href="#tagRef_dynaXML_ReqParser_Output_Source">&lt;source&gt;</a>
          <a href="#tagRef_dynaXML_ReqParser_Output_Brand">&lt;brand&gt;</a>
          <a href="#tagRef_dynaXML_ReqParser_Output_Index">&lt;index&gt;</a>
          <a href="#tagRef_dynaXML_ReqParser_Output_Query">&lt;query&gt;</a>
          <a href="#tagRef_dynaXML_ReqParser_Output_PublicAuth">Public Authentication</a>
          <a href="#tagRef_dynaXML_ReqParser_Output_IPAuth">IP List Authentication</a>
          
          <a href="#tagRef_dynaXML_ReqParser_Output_LDAPAuth">LDAP Authentication</a>
          <a href="#tagRef_dynaXML_ReqParser_Output_ExtAuth">External Authentication</a></blockquote>
        
        <ul>
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_Style">&lt;style&gt;</a></u>
              
              This tag identifies the location of the <strong>Document Formatter</strong> Stylesheet. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;style path="DocFormatterLocation"/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>path=</tt>"DocFormatterLocation"</td>
                    <td>is the file path and name for the <strong>Document Formatter</strong> stylesheet to use for the requested document. If this path is not specified as an absolute path, it is assumed to be relative to the base XTF installation directory (i.e., <strong>XTF_HOME</strong>.)</td>
                  </tr>
                </tbody>
              </table>
            
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_Source">&lt;source&gt;</a></u>
              
              This tag identifies the location of the document to be retrieved. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;source path="SrcDocLocation"/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>path=</tt>"SrcDocLocation"</td>
                    <td>is the file path and name for the document to be retrieved. If this path is not specified as an absolute path, it is assumed to be relative to the base XTF installation directory (i.e., <strong>XTF_HOME</strong>.)</td>
                  </tr>
                </tbody>
              </table>
            
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_Brand">&lt;brand&gt;</a></u>
              
              This tag identifies a file that contains a list of site-specific parameters to be passed on to the document formatter. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;brand path="BrandStylesheetLocation"/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>path=</tt>"BrandStylesheetLocation"</td>
                    <td>is the file path and name for the brand file to use. If this path is not specified as an absolute path, it is assumed to be relative to the base XTF installation directory (i.e., <strong>XTF_HOME</strong>.)</td>
                  </tr>
                </tbody>
              </table>
              This contents of the branding file is a set of parameter definitions of the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;name&gt;value&lt;/name&gt;
&lt;name&gt;value&lt;/name&gt;
…</pre>
              These parameters are most often used to pass "branding" information to the <strong>Document Formatter</strong> stylesheet (e.g., background color to use, cascading stylesheet to use, font to use, etc.)
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_Index">&lt;index&gt;</a></u>
              
              This tag identifies the index to use for lazy loading of text, and for marking search hits in a document. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;index configPath="TextIndexerConfigLocation" name="IndexName"/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>configPath=</tt>"TextIndexerConfigLocation"</td>
                    <td>is the file path and name for the textIndexer config file. If this path is not specified as an absolute path, it is assumed to be relative to the base XTF installation directory (i.e., <strong>XTF_HOME</strong>.)</td>
                  </tr>
                  <tr>
                    <td><tt>name=</tt>"IndexName"</td>
                    <td>is the name of the index to use. This index name must exist in the config file specified by the configPath attribute above.</td>
                  </tr>
                </tbody>
              </table>
              This tag is required if the document request passed to the dynaXML servlet will include a <a href="#tagRef_dynaXML_ReqParser_Output_Query">query</a> tag. Using the <a href="#tagRef_dynaXML_ReqParser_Output_Query">query</a> tag in a document request without an index tag will result in an <a href="#ErrorGenerators_UnsupportedQuery">Unsupported Query Error</a> being sent to the <strong>Error Generator</strong> stylesheet.
              
              Placing this tag in a document request will also enable lazy loading of the requested document (i.e., portions of the document are loaded only when viewed by the user.) Using lazy loading can substantially increase the responsiveness of the XTF system for libraries of large documents.
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_Query">&lt;query&gt;</a></u>
              
              This tag is a container tag for a crossQuery style query. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;query&gt;

    crossQuery-Style Query Tags
                
&lt;/query&gt;</pre>
              where crossQuery-Style Query Tags are any of the query tags outlined in the <a href="#tagRef_crossQuery_QueryParser_Output">Query Parser Output Tags</a> section. Note however that the dynaXML query tag doesn't use the attributes available for the crossQuery <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag.
              
              Including a query in the document request allows the dynaXML servlet to mark query hits in context in the original document. Then, the <strong>Document Formatter</strong> stylesheet can opt to provide quick links to the hits or to simply highlight them in context.
              
              Note: If a query tag is used in a document request, the <a href="#tagRef_dynaXML_ReqParser_Output_Index">index</a> tag <strong>must</strong> also be present in the document request. If the <a href="#tagRef_dynaXML_ReqParser_Output_Index">index</a> tag is not present in the document request, an <a href="#ErrorGenerator_UnsupportedQuery">Unsupported Query</a> error will be sent to the <strong>Error Generator</strong> stylesheet.
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_PublicAuth">Public Authentication</a></u>
              
              This variant of the authentication tag is used to provide or deny full public access to documents. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;auth access="AllowOrDeny" type="all"/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>access=</tt>"AllowOrDeny"</td>
                    <td>specifies whether all users should be allowed access (access="allow") or denied access (access="deny") to the requested document.</td>
                  </tr>
                </tbody>
              </table>
              Allowing access to all users with this tag can be used when no special authorization is required to access on-line documents.
              
              Note: One or more auth tags must exist in the <strong>Document Request Parser</strong> stylesheet. These tags will be processed in the order they are encountered until one of them authorizes or denies access. If none of the authentication tags explicitly authorize or deny access, the dynaXML servlet will deny access by default.
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_IPAuth">IP List Authentication</a></u>
              
              This variant of the authentication tag is used to provide access to documents based on the user's IP address. This tag provides simple (but not particularly robust) authorization for document access. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;auth access="AllowOrDeny" type="IP" list="LocationOfIPList"/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>access=</tt>"AllowOrDeny"</td>
                    <td>specifies whether addresses in the IP list should be allowed access (access="allow") or denied access (access="deny") to the requested document.</td>
                  </tr>
                  <tr>
                    <td><tt>list=</tt>"LocationOfIPList"</td>
                    <td>specifies the path and filename of a list of IP addresses to allow or deny access. If not specified as an absolute path, this path is assumed to be relative to the XTF base install directory (i.e., XTF_HOME.) To learn about the format of the IP List file, see the <a href="http://xtf.cdlib.org/documentation/deployment-guide/#UserAuthentication">XTF Deployment Guide</a>.</td>
                  </tr>
                </tbody>
              </table>
              Note: One or more auth tags must exist in the <strong>Document Request Parser</strong> stylesheet. These tags will be processed in the order they are encountered until one of them authorizes or denies access. If none of the authentication tags explicitly authorize or deny access, the dynaXML servlet will deny access by default.
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_LDAPAuth">LDAP Authentication</a></u>
              
              This variant of the authentication tag is used to provide access to documents based on an LDAP database. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;auth access        = "allow"
      type          = "LDAP"
      server        = "LDAPServerURL"
      realm         = "PswdRequestDescr"
     {bindName      = "LDAPConnectName"}
     {bindPassword  = "LDAPConnectPswd"}
     {queryName     = "LDAPRecordNameToFind"}
     {matchField    = "LDAPFieldToFind"}
     {matchValue    = "LDAPValueToMatch"}/&gt;</pre>
              where
              <table border="1">
                <tbody>
                  <tr>
                    <td><tt>server=</tt>"LDAPServerURL"</td>
                    <td>identifies the location of the LDAP server to use.</td>
                  </tr>
                  <tr>
                    <td><tt>realm=</tt>"PswdDialogDescr"</td>
                    <td>is a string to display in the browser dialog box that asks for the user's name and password.</td>
                  </tr>
                  <tr>
                    <td><tt>bindName=</tt>"LDAPConnectName"</td>
                    <td>is an optional attribute specifying the name to use when connecting to the LDAP server. If this attribute is omitted, then an anonymous LDAP connection will be attempted.   If anonymous connections are permitted by the LDAP database, then the bindPassword attribute should also be omitted, and the queryName  attribute must be present for user authentication to proceed. For anonymous LDAP access the  matchField  and matchValue attributes are optional.   If the name passed for this attribute is the LDAP administrator name, then the bindPassword  attribute must be set to the LDAP administrator password, and the queryName must also be present for user authentication to proceed. For administrative LDAP access, the matchField and matchValue  attributes are optional.   It should also be noted that the user name will be substituted for any occurrence of the %  symbol in this attribute. Doing so allows connections with the LDAP database to be established using the user name instead of an LDAP administrator name.   Finally, if successfully connecting to the LDAP database with a user name and password is all that is required for authentication, then no other attributes need to be specified in the authentication tag. Otherwise, the  queryName  attribute and optionally the matchField  and matchValue  attributes may be specified to complete the authentication request.</td>
                  </tr>
                  <tr>
                    <td><tt>bindPassword=</tt>"LDAPConnectPswd"</td>
                    <td>is an optional attribute specifying the password to use when connecting to the LDAP server.   If an anonymous LDAP connection is being performed (i.e, the bindName attribute has not been specified), this attribute should also not appear in the authentication tag.   If the bindName attribute specifies the LDAP administrator name, this attribute must be set to the LDAP administrator password.   Finally, the user password will be substituted for any occurrence of the %  symbol in this attribute. Doing so allows connections with the LDAP database to be established using the user password instead of an LDAP administrator password.</td>
                  </tr>
                  <tr>
                    <td><tt>queryName=</tt>"LDAPRecordToFind"</td>
                    <td>is an attribute identifying the name of an LDAP record to find. If an anonymous or administrator connection to the LDAP server is being attempted, this attribute is required. For user connections, this attribute is optional.   As with the bindName attribute, the user name will be substituted for any occurrence of the % symbol in this attribute. Doing so allows connections with the LDAP database to be established using the user name instead of an LDAP administrator name.   Also, if the  queryName attribute is specified without the matchField or matchValue attributes, then user authentication will succeed if the given record name simply exists in the LDAP database. If the given record is not in the LDAP database, authentication will fail.</td>
                  </tr>
                  <tr>
                    <td><tt>matchField=</tt>"LDAPFieldToFind"</td>
                    <td>is an attribute identifying the name of a field to find in the LDAP record named by the queryName attribute. Note that the matchField  attribute should not be used if the queryName attribute hasn't been specified.   Like the queryName attribute, the user name will be substituted for any occurrence of the % symbol in this attribute. Doing so allows connections with the LDAP database to be established using the user name instead of an LDAP administrator name.   Finally, if the  matchField attribute is specified without the matchValue  attribute, then user authentication will succeed if the given field name simply exists in the LDAP record. If the given field name does not exist in the LDAP database authentication will fail.</td>
                  </tr>
                  <tr>
                    <td><tt>matchValue=</tt>"LDAPValueToMatch"</td>
                    <td>is an attribute that specifies the value that must exist in the LDAP field named by the matchField attribute for authentication to succeed. If the specified value doesn't match the LDAP field, user authentication will fail.   As with the previous attributes, the user's password will be substituted for any occurrences of the % symbol. Doing so allows connections with the LDAP database to be established using the user password instead of an LDAP administrator password.</td>
                  </tr>
                </tbody>
              </table>
              Note: One or more auth tags must exist in the <strong>Document Request Parser</strong> stylesheet. These tags will be processed in the order they are encountered until one of them authorizes or denies access. If none of the authentication tags explicitly authorize or deny access, the dynaXML servlet will deny access by default.
          </li>
          
          <li><u><a name="tagRef_dynaXML_ReqParser_Output_ExtAuth">External Authentication</a></u>
              
              This variant of the authentication tag is used to provide access to documents based on an external authentication web-page or server. It has the form:
              <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;auth access = "allow"
      type   = "external"
      key    = "SecretKeyStr"
      url    = "AuthenticationURL"/&gt;</pre>
              Note: One or more auth tags must exist in the <strong>Document Request Parser</strong> stylesheet. These tags will be processed in the order they are encountered until one of them authorizes or denies access. If none of the authentication tags explicitly authorize or deny access, the dynaXML servlet will deny access by default. For more details about external authentication, see the <a href="http://xtf.cdlib.org/documentation/deployment-guide/#UserAuthentication">XTF Deployment Guide</a>.
          </li>
        </ul>
      </li>
    </ul>
    
    <h2><a name="DocFormatter">Document Formatter</a></h2>
    
    The following tags and attributes are added by the dynaXML servlet to the original XML tags that make up the requested XML document, which are then passed to the <strong>Document Formatter</strong> stylesheet for output formatting.
    
    <h3>Document Formatter Attributes</h3>        
    
    <pre style="background-color: #f0f0f0; border: 1px solid black;">xtf:hitCount="NumberOfHitsBelowThisTag"
xtf:firstHit="FirstHitNumberBelowThisTag"</pre>
    These attributes are added to XML documents to indicate where matched text hits are located. By providing these tags, the dynaXML servlet allows the <strong>Document Formatter</strong> stylesheet to quickly determine if a section of a document needs any special highlighting or not.
    
    If the requested document has no hits, these attributes will appear once in the outermost tag for the document with both the attributes set to zero. If the document has one or more hits, these attributes will appear for any XML tag that has a hit inside it or inside its child tags.
      
    <h3>Document Formatter Tags</h3>
    
    <blockquote><a href="#tagRef_dynaXML_DocFormatter_Snippets">&lt;xtf:snippets&gt;</a>
      <a href="#tagRef_dynaXML_DocFormatter_Snippet">&lt;xtf:snippet&gt;</a>
      
      <a href="#tagRef_dynaXML_DocFormatter_Hit">&lt;xtf:hit&gt;</a>
      <a href="#tagRef_dynaXML_DocFormatter_More">&lt;xtf:more&gt;</a>
      <a href="#tagRef_dynaXML_DocFormatter_Term">&lt;xtf:term&gt;</a>
    </blockquote>
    
    <ul>
      <li><u><a name="tagRef_dynaXML_DocFormatter_Snippets">&lt;xtf:snippets&gt;</a></u>
          
          This tag is a container tag added to the start of the document when there are query results for the document. It has the form:
          <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xtf:snippets&gt;

   Snippet
   Snippet
   …

&lt;/xtf:snippets&gt;</pre>
          where each Snippet is a dynaXML <a href="#tagRef_dynaXML_DocFormatter_Snippet">snippet</a> tag that summarizes one query match in the requested document.
          
          Note: The <tt>&lt;snippets&gt;</tt> tag is prefixed with the xtf: namespace to differentiate it from tags that came from the original XML document.
      </li>
      
      <li><u><a name="tagRef_dynaXML_DocFormatter_Snippet">&lt;xtf:snippet&gt;</a></u>
          
          This tag contains a snippet of text associated with a match found in the requested document. The snippet consists of the text matched along with some context text around it. This tag has the form:
          <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xtf:snippet hitNum="HitNumber" 
              rank="MatchRelevanceRank" 
              score="MatchRelevanceScore"&gt;

    Hit Text (and context text, if any)

&lt;/xtf:snippet&gt;</pre>
          where
          <table border="1">
            <tbody>
              <tr>
                <td><tt>xtf:</tt></td>
                <td>is an XTF namespace prefix added to the tag to differentiate it from tags that came from the original XML document. The namespace URI for this prefix is: <tt>http://cdlib.org/xtf</tt></td>
              </tr>
              <tr>
                <td><tt>hitNum=</tt>"HitNumber"</td>
                <td>is the ordinal ID of the current hit. This attribute will also appear in <a href="#tagRef_dynaXML_DocFormatter_Hit">hit</a> tags in the main text, allowing the hit number for the next or previous in-context tag to be easily determined.</td>
              </tr>
              <tr>
                <td><tt>rank=</tt>"MatchRelevanceRank"</td>
                <td>is the ranking of this match in the current document, with 1 being the most relevant match in the document.</td>
              </tr>
              <tr>
                <td><tt>score=</tt>"MatchRelevanceScore"</td>
                <td>is the relevance score for this match ranging from 0% to 100%. The snippet with the highest overall relevance will receive a score of 100%, and less relevant snippets will receive lower scores.</td>
              </tr>
            </tbody>
          </table>
          The amount of context text displayed in a snippet is determined by the <a href="#tagRef_crossQuery_QueryParser_Output_Query">query</a> tag in the original query. If the context length specified is less than the matched text, then only the matched text will be displayed.
          
          Within the snippet itself, each matching word from the query will be marked with a single  <a href="#tagRef_dynaXML_DocFormatter_Term">Term Tag</a>, and the matching text around which the context text is centered on will also be marked with a single  <a href="#tagRef_dynaXML_DocFormatter_Hit">Hit Tag</a>.
      </li>
      
      <li><u><a name="tagRef_dynaXML_DocFormatter_Hit">&lt;xtf:hit&gt;</a></u>
          
          This tag identifies actual matched text in a <a href="#tagRef_dynaXML_DocFormatter_Snippet">snippet</a> tag or in the main text for the requested document. This tag has the form:
          <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xtf:hit hitNum    = "HitNumber"
         rank      = "MatchRelevanceRank"
         score     = "MatchRelevanceScore"
         continues = "YesOrNo"&gt;
         
    …
    
&lt;/xtf:hit&gt;</pre>
          where
          <table border="1">
            <tbody>
              <tr>
                <td><tt>xtf:</tt></td>
                <td>is an XTF namespace prefix added to the tag to differentiate it from tags that came from the original XML document. The prefix will not be present in hit tags that appear within the initial <a href="#tagRef_dynaXML_DocFormatter_Snippets">snippets</a> summary tag, but only in hit tags that occur in the main text for the document. The namespace URI for this prefix is: <tt>http://cdlib.org/xtf</tt></td>
              </tr>
              <tr>
                <td><tt>hitNum=</tt>"HitNumber"</td>
                <td>is the ordinal ID of the current hit. This attribute allows the hit number for the next or previous in-context tag to be easily determined.</td>
              </tr>
              <tr>
                <td><tt>rank=</tt>"MatchRelevanceRank"</td>
                <td>is the ranking of this match in the current document, with 1 being the most relevant match in the document.</td>
              </tr>
              <tr>
                <td><tt>score=</tt>"MatchRelevanceScore"</td>
                <td>is the relevance score for this match ranging from 0% to 100%. The snippet with the highest overall relevance will receive a score of 100%, and less relevant snippets will receive lower scores.</td>
              </tr>
              <tr>
                <td><tt>continues=</tt>"YesOrNo"</td>
                <td>indicates whether this hit continues into the next XML tag (continues="<strong>yes</strong>") or not (continues="<strong>no</strong>"). Note that when a hit continues into the next XML tag, a <a href="#tagRef_dynaXML_DocFormatter_More">More Tag</a> will always follow.</td>
              </tr>
            </tbody>
          </table>
          A hit may contain one or more matched words, which are separately marked with <a href="#tagRef_dynaXML_DocFormatter_Term">Term Tags</a>.
          
          If the query in the document request included a <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a> or <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a> clause, the Hit Tag will mark the entire range of text between the first and last word found for the clause. Also, within the main text, if the entire range spans multiple XML tags in the document, the hit will be broken down into an initial Hit Tag followed by one or more <a href="#tagRef_dynaXML_DocFormatter_Term">More Tags</a>.
          
          For summary snippets, if the query for the requested document includes an <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a> clause, all the matched words in the snippet will be marked with <a href="#tagRef_dynaXML_DocFormatter_Term">Term Tags</a>, but only the word that the snippet is centered around will be marked with a hit tag. Within the main text however, any term matched in the <a href="#tagRef_crossQuery_QueryParser_Output_Or">or</a> clause will be marked with <strong>both</strong> a Hit Tag and a <a href="#tagRef_dynaXML_DocFormatter_Term">Term Tag</a>.
      </li>
      
      <li><u><a name="tagRef_dynaXML_DocFormatter_More">&lt;xtf:more&gt;</a></u>
          
          This tag identifies the continuation of a <a href="#tagRef_dynaXML_DocFormatter_Hit">hit</a> tag that started in a previous XML tag. This tag has the form:
          <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xtf:more hitNum    = "HitNumber"
          rank      = "MatchRelevanceRank"
          score     = "MatchRelevanceScore"
          continues = "YesOrNo"&gt;

    …

&lt;/xtf:more&gt;</pre>
          where
          <table border="1">
            <tbody>
              <tr>
                <td><tt>xtf:</tt></td>
                <td></td>
                <td>is an XTF namespace prefix added to the tag to differentiate it from tags that came from the original XML document. The namespace URI for this prefix is: <tt>http://cdlib.org/xtf</tt></td>
              </tr>
              <tr>
                <td><tt>hitNum=</tt>"HitNumber"</td>
                <td></td>
                <td>is the ordinal ID of the hit to which this More Tag belongs.</td>
              </tr>
              <tr>
                <td><tt>rank=</tt>"MatchRelevanceRank"</td>
                <td></td>
                <td>is the ranking of the hit to which this More Tag belongs.</td>
              </tr>
              <tr>
                <td><tt>score=</tt>"MatchRelevanceScore"</td>
                <td></td>
                <td>is the relevance score of the hit to which this More Tag belongs.</td>
              </tr>
              <tr>
                <td><tt>continues=</tt>"YesOrNo"</td>
                <td></td>
                <td>indicates whether the associated hit continues into yet another XML tag (continues="<strong>yes</strong>") or not (continues="<strong>no</strong>"). Note that when a hit continues into another XML tag, another <a href="#tagRef_dynaXML_DocFormatter_More">more</a> tag will always follow.</td>
              </tr>
            </tbody>
          </table>
          A More Tag may contain one or more matched words, which are separately marked with <a href="#tagRef_dynaXML_DocFormatter_Term">Term Tags</a>.
          
          If the query in the document request included a <a href="#tagRef_crossQuery_QueryParser_Output_Near">near</a> or <a href="#tagRef_crossQuery_QueryParser_Output_And">and</a> clause, and the entire range of the hits spans multiple XML tags in the document, the More Tag will mark any parts of the range that occur in subsequent XML tags.
      </li>
      
      <li><u><a name="tagRef_dynaXML_DocFormatter_Term">&lt;xtf:term&gt;</a></u>
          
          This tag identifies a single word in the main text that matches a query associated with the requested document. This tag has the form:
          <pre style="background-color: #f0f0f0; border: 1px solid black;">&lt;xtf:term&gt;MatchedWord&lt;/xtf:term&gt;</pre>
          where
          <table border="1">
            <tbody>
              <tr>
                <td><tt>xtf:</tt></td>
                <td></td>
                <td>is an XTF namespace prefix added to the tag to differentiate it from tags that came from the original XML document. The prefix will not be present in term tags that appear within the initial <a href="#tagRef_dynaXML_DocFormatter_Snippets">snippets</a> summary tag, but only in term tags that occur in the main text for the document. The namespace URI for this prefix is: <tt>http://cdlib.org/xtf</tt></td>
              </tr>
            </tbody>
          </table>
      </li>
    </ul>
      
    <h3><a name="ErrorGenerator">Error Generator</a></h3>
    The purpose of the <strong>Error Generator</strong> stylesheet is to generate a web-page that displays user friendly messages when dynaXML errors occur. Since this stylesheet works the same way in both dynaXML and crossQuery, it is documented on the common <a href="#tagRef_Error_Generators">Error Generator Stylesheets</a> page.
  </body>
</html>